{"meta":{"title":"小码侠","subtitle":"代码大侠","description":"Golang、 PHP、 Java、 vue. js 手到擒来。服务器运维更是不在话下 shell、 Docker、 Zabbix、 Redis、 Elasticsearch、 MongoDb、 MySql……。","author":"wolferhua","url":"https://wolferhua.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-02-10T11:07:12.011Z","updated":"2020-02-10T11:07:12.011Z","comments":false,"path":"/404.html","permalink":"https://wolferhua.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2020-02-10T11:07:12.021Z","updated":"2020-02-10T11:07:12.021Z","comments":false,"path":"about/index.html","permalink":"https://wolferhua.github.io/about/index.html","excerpt":"","text":"Golang、PHP、Java、vue.js 手到擒来。服务器运维更是不在话下，Docker、Zabbix、Redis、Elasticsearch、MongoDb……无所不知。"},{"title":"书单","date":"2020-02-10T11:07:12.021Z","updated":"2020-02-10T11:07:12.021Z","comments":false,"path":"books/index.html","permalink":"https://wolferhua.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-02-10T11:07:12.021Z","updated":"2020-02-10T11:07:12.021Z","comments":false,"path":"categories/index.html","permalink":"https://wolferhua.github.io/categories/index.html","excerpt":"","text":""},{"title":"Getalk","date":"2020-02-10T11:07:12.028Z","updated":"2020-02-10T11:07:12.028Z","comments":true,"path":"getalk/index.html","permalink":"https://wolferhua.github.io/getalk/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-02-10T11:07:12.062Z","updated":"2020-02-10T11:07:12.062Z","comments":true,"path":"links/index.html","permalink":"https://wolferhua.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-02-10T11:07:12.062Z","updated":"2020-02-10T11:07:12.062Z","comments":false,"path":"repository/index.html","permalink":"https://wolferhua.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-02-10T11:07:12.063Z","updated":"2020-02-10T11:07:12.063Z","comments":false,"path":"tags/index.html","permalink":"https://wolferhua.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-02-10T11:07:12.023Z","updated":"2020-02-10T11:07:12.023Z","comments":true,"path":"downloads/code/docker/004/index.html","permalink":"https://wolferhua.github.io/downloads/code/docker/004/index.html","excerpt":"","text":"Hello World!"},{"title":"","date":"2020-02-10T11:07:12.024Z","updated":"2020-02-10T11:07:12.024Z","comments":true,"path":"downloads/code/docker/009-nginx/docker-compose.dev.json","permalink":"https://wolferhua.github.io/downloads/code/docker/009-nginx/docker-compose.dev.json","excerpt":"","text":"{\"version\":\"3\",\"services\":{\"nginx\":{\"image\":\"nginx\",\"depends_on\":[\"goweb\"],\"ports\":[\"80:80\"]},\"goweb\":{\"image\":\"goweb\"},\"alpine\":{\"image\":\"daocloud.io/alpine\",\"command\":[\"ping\",\"127.0.0.1\"]}}}"},{"title":"","date":"2020-02-10T11:07:12.023Z","updated":"2020-02-10T11:07:12.023Z","comments":true,"path":"downloads/code/docker/009-nginx/docker-compose.1.json","permalink":"https://wolferhua.github.io/downloads/code/docker/009-nginx/docker-compose.1.json","excerpt":"","text":"{\"version\":\"3\",\"services\":{\"nginx\":{\"networks\":[\"networkce\"],\"build\":{\"context\":\".\"},\"image\":\"test/nginx:compose\",\"depends_on\":[\"goweb\"]},\"goweb\":{\"networks\":[\"networkce\"],\"build\":{\"context\":\"../004-go\"},\"image\":\"test/goweb:compose\",\"deploy\":{\"mode\":\"replicated\",\"replicas\":5,\"resources\":{\"limits\":{\"cpus\":\"0.5\",\"memory\":\"50M\"},\"reservations\":{\"cpus\":\"0.2\",\"memory\":\"20M\"}}}},\"alpine\":{\"networks\":[\"networkce\"],\"image\":\"daocloud.io/alpine\",\"command\":[\"ping\",\"127.0.0.1\"]}},\"networks\":{\"networkce\":{\"driver\":\"overlay\"}}}"},{"title":"","date":"2020-02-10T11:07:12.024Z","updated":"2020-02-10T11:07:12.024Z","comments":true,"path":"downloads/code/docker/009-nginx/docker-compose.json","permalink":"https://wolferhua.github.io/downloads/code/docker/009-nginx/docker-compose.json","excerpt":"","text":"{\"version\":\"3\",\"services\":{\"nginx\":{\"build\":{\"context\":\".\"},\"image\":\"test/nginx:compose\",\"depends_on\":[\"goweb\"],\"ports\":[\"80:80\"]},\"goweb\":{\"build\":{\"context\":\"../004-go\"},\"ports\":[8080],\"image\":\"test/goweb:compose\"},\"alpine\":{\"image\":\"daocloud.io/alpine\",\"command\":[\"ping\",\"127.0.0.1\"]}}}"},{"title":"","date":"2020-02-10T11:07:12.024Z","updated":"2020-02-10T11:07:12.024Z","comments":true,"path":"downloads/code/docker/009-nginx/index.html","permalink":"https://wolferhua.github.io/downloads/code/docker/009-nginx/index.html","excerpt":"","text":"Hello compose!"},{"title":"","date":"2020-02-10T11:07:12.024Z","updated":"2020-02-10T11:07:12.024Z","comments":true,"path":"downloads/code/docker/011-adv/docker-compose.json","permalink":"https://wolferhua.github.io/downloads/code/docker/011-adv/docker-compose.json","excerpt":"","text":"{\"version\":\"3\",\"services\":{\"alpine\":{\"image\":\"daocloud.io/alpine\",\"command\":[\"ping\",\"127.0.0.1\"],\"deploy\":{\"mode\":\"global\"},\"restart\":\"always\"},\"nginx\":{\"image\":\"192.168.65.95:5000/nginx:goweb\",\"depends_on\":[\"goweb\"],\"ports\":[\"80:80\"],\"deploy\":{\"mode\":\"global\"},\"restart\":\"always\"},\"goweb\":{\"image\":\"192.168.65.95:5000/goweb:goweb\",\"deploy\":{\"mode\":\"replicated\",\"replicas\":3},\"restart\":\"always\"}}}"},{"title":"","date":"2020-02-10T11:07:12.025Z","updated":"2020-02-10T11:07:12.025Z","comments":true,"path":"downloads/code/docker/011-base/docker-compose.json","permalink":"https://wolferhua.github.io/downloads/code/docker/011-base/docker-compose.json","excerpt":"","text":"{\"version\":\"3\",\"services\":{\"alpine\":{\"image\":\"daocloud.io/alpine\",\"command\":[\"ping\",\"127.0.0.1\"],\"deploy\":{\"mode\":\"global\"},\"restart\":\"always\"},\"alpine-replicated\":{\"image\":\"daocloud.io/alpine\",\"command\":[\"ping\",\"127.0.0.1\"],\"deploy\":{\"mode\":\"replicated\",\"replicas\":5},\"restart\":\"always\"}}}"},{"title":"","date":"2020-02-10T11:07:12.025Z","updated":"2020-02-10T11:07:12.025Z","comments":true,"path":"downloads/code/docker/011-adv/nginx/index.html","permalink":"https://wolferhua.github.io/downloads/code/docker/011-adv/nginx/index.html","excerpt":"","text":"Hello compose!"},{"title":"","date":"2020-02-10T06:43:53.258Z","updated":"2020-02-10T06:43:53.258Z","comments":true,"path":"downloads/code/go-micro-demo/demo001/webdemo/README.html","permalink":"https://wolferhua.github.io/downloads/code/go-micro-demo/demo001/webdemo/README.html","excerpt":"","text":"Web API本篇演示如何使用Web模式下的Micro API，以下简称API。 在web代理模式下运行API，我们可以将API作为反向代理提供下游服务的http接口，示例中我们演示使用websocket。 API会向注册中心查询服务信息，将请求路由转向合适的后台服务上。故而我们直接使用go-web作为后台服务，因为它可以直接注册，为了方便我们不直接从头写可以注册的服务。 使用方法以web模式运行API 1micro api --handler=web 运行web应用 1go run web.go 演示打开 http://127.0.0.1:8080/websocket/ 默认会打开websocket连接。在Name栏中输入文本，点击send按钮便可以与后台websocket服务交互。"},{"title":"","date":"2020-02-10T10:54:44.043Z","updated":"2020-02-10T10:54:44.043Z","comments":true,"path":"downloads/code/go-micro-demo/demo001/web1/html/index.html","permalink":"https://wolferhua.github.io/downloads/code/go-micro-demo/demo001/web1/html/index.html","excerpt":"","text":"Go Web1 body { padding-top: 100px; } .main-body > .row { margin-top: 30px; margin-bottom: 30px; } .message-box{ padding: 30px; } 欢迎使用。 在线用户列表： Send"},{"title":"","date":"2020-02-10T10:55:40.516Z","updated":"2020-02-10T10:55:40.516Z","comments":true,"path":"downloads/code/go-micro-demo/demo001/web1/html/index.js","permalink":"https://wolferhua.github.io/downloads/code/go-micro-demo/demo001/web1/html/index.js","excerpt":"","text":"//alert(\"message\") (function ($) { const sessionKey = 'name'; const host = window.location.host; const wsUrl = \"ws://\" + host + \"/web1/ws?name=\"; let $messageBox = $(\".message-box\"); //消息框 let $message = $(\"#message\"); //消息内容 let $sendBut = $(\"#send-but\"); //消息按钮 let $userList = $(\".user-list\");//用户列表 let ws = null; // 获取用户名称 let name = sessionStorage.getItem(sessionKey);// 如果存在 // 加载用户列表 let loadUserList = _.debounce(function () { //console.log($) $.ajax({ url:'/web1/ws/users', dataType:'json', success:function (ret) { //console.log(ret); // 渲染消息数据 let $warp = $(''); for (let i in ret){ $warp.append(''+ret[i]+'') } $userList.html($warp.html()); } }) },3000); // 显示消息 function writeMessage(content) { let item = $(''); item.html(content); writeMessageRow(item); } function writeMessageRow(content) { let item = $(''); item.html(content); $messageBox.append(item); } // 名称输入提示 function namePrompt() { // 没有存储名称。 do { name = window.prompt(\"请输入名称：\"); name = name.trim(); // 存入本地存储 sessionStorage.setItem(sessionKey, name); } while (!name) } // 链接服务器 function connectServer() { ws = new WebSocket(wsUrl + name); // 事件监听 ws.onopen = function (evt) { writeMessage('与服务器链接已经建立。'); loadUserList(); }; ws.onclose = function (evt) { writeMessage('链接断开，请重新链接。'); ws = null; }; ws.onmessage = function (evt) { let data = JSON.parse(evt.data); if (!data || !data.code || !data.message) return; // 消息体不匹配 if (data.code >= 500) { // 系统异常消息：退出，并关闭链接 sessionStorage.removeItem(sessionKey); writeMessage('' + data.message + ''); ws = null; return; } if (data.code >= 200) { // 用户消息。显示消息内容 var message = ''; if (data.name == name) { //本人发送消息 message += '' + data.name + '' } else { //其他人发送消息 message += '' + data.name + '' } message += '' + data.message + ''; writeMessageRow(message); return; } // 系统通知消息 if (data.code >= 100) { writeMessage('' + data.message + ''); loadUserList(); return; } }; ws.onerror = function (evt) { writeMessage('服务器错误，请重新链接。'); ws = null; }; } // 节流函数，防止重复点击。 let send = _.debounce(function () { var content = $message.val().trim(); if (!content) { alert('请输入内容！'); return; } if (ws == null) { namePrompt(); connectServer(); } ws.send(content); $message.val(''); $message.focus(); }, 200); // 回车键发送消息 $message.keypress(function (event) { if (event.keyCode === 13) { // 阻止事件冒泡 if (event.preventDefault) event.preventDefault; event.returnValue = false; // 发送消息 send(); return false; } }); // 按钮发送 $sendBut.click(send); // 开始连接。 if (name) { connectServer(); } else { namePrompt(); connectServer(); } })(jQuery);"},{"title":"","date":"2020-02-10T06:43:53.259Z","updated":"2020-02-10T06:43:53.259Z","comments":true,"path":"downloads/code/go-micro-demo/demo001/webdemo/html/index.html","permalink":"https://wolferhua.github.io/downloads/code/go-micro-demo/demo001/webdemo/html/index.html","excerpt":"","text":"Websocket Stream table { table-layout: fixed; } td { border: 2px solid green; } td input { width: 100%; box-sizing: border-box; } Websocket Stream Name: Send Cancel Open Connection"},{"title":"","date":"2020-02-10T06:43:53.259Z","updated":"2020-02-10T06:43:53.259Z","comments":true,"path":"downloads/code/go-micro-demo/demo001/webdemo/html/main.js","permalink":"https://wolferhua.github.io/downloads/code/go-micro-demo/demo001/webdemo/html/main.js","excerpt":"","text":"window.addEventListener(\"load\", function (evt) { var wsUri = \"ws://localhost:8080/websocket/hi\" var output = document.getElementById(\"output\"); var nameTxt = document.getElementById(\"name\"); var ws; var print = function (message) { var d = document.createElement(\"div\"); d.innerHTML = message; output.appendChild(d); }; (function () { ws = new WebSocket(wsUri); ws.onopen = function (evt) { print('Connection Open'); } ws.onclose = function (evt) { print('Connection Closed'); ws = null; } ws.onmessage = function (evt) { print('Update: ' + evt.data); } ws.onerror = function (evt) { print('Error: ' + evt.data); } })(); document.getElementById(\"send\").onclick = function (evt) { if (!ws) { return false } var msg = {hi: nameTxt.value} req = JSON.stringify(msg) print('Sent request: ' + req); ws.send(JSON.stringify(msg)); return false; }; document.getElementById(\"cancel\").onclick = function (evt) { if (!ws) { return false; } ws.close(); print('Request Canceled'); return false; }; document.getElementById(\"open\").onclick = function (evt) { if (!ws) { newSocket() } return false; }; })"}],"posts":[{"title":"Vagrant指南","slug":"vagrant-guide-1","date":"2020-02-13T15:05:17.000Z","updated":"2020-02-14T05:48:10.376Z","comments":true,"path":"2020/02/13/vagrant-guide-1/","link":"","permalink":"https://wolferhua.github.io/2020/02/13/vagrant-guide-1/","excerpt":"","text":"Vagrant介绍是什么？Vagrant是一个基于Ruby的工具，用于创建和部署虚拟化开发环境。它 使用Oracle的开源VirtualBox虚拟化系统，使用 Chef创建自动化虚拟环境。目前vagrant还可以使用vmware,docker……等十多种虚拟机提供服务，但是常用的还是VirtualBox。 基础概念Box在Vagrant体系中，有个box(箱子)的概念，这优点类似于docker体系中的image(镜像)，也可以理解为一个系统的安装包。基于同一个box，不同的人可以运行得到相同的内容。 安装 安装 VirtualBox：https://www.virtualbox.org/wiki/Downloads； 安装 Vagrant：https://www.vagrantup.com/downloads.html。 需要注意的是， VirtualBox版本一定要在 Vagrant版本支持的列表中，本文档用Vagrant 2.2.7支持VirtualBox： 4.0.x, 4.1.x, 4.2.x, 4.3.x, 5.0.x, 5.1.x, 5.2.x, 6.0.x, and 6.1.x. 傻瓜式安装，下载对应系统版本的软件以后，一直点击下一步，下一步即可。这里就演示了。 基础使用一、创建目录1234## 目录位置无所谓，没有具体要求。mkdir ubuntu1806cd ubuntu1806 二、初始化12345678910111213vagrant init ubuntu/bionic64# A `Vagrantfile` has been placed in this directory. You are now# ready to `vagrant up` your first virtual environment! Please read# the comments in the Vagrantfile as well as documentation on# `vagrantup.com` for more information on using Vagrant.### 看一下目录里边有什么？ls -la# total 8# drwxr-xr-x 3 wolferhua staff 96 2 13 15:32 .# drwxr-xr-x 5 wolferhua staff 160 2 13 15:31 ..# -rw-r--r-- 1 wolferhua staff 3021 2 13 15:32 Vagrantfile 可以发现，目录里边自动创建了一个Vagrantfile,我们看下里边内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879### cat Vagrantfile# 可以看到内容比较多，但是大部分都是注释内容。我们暂时忽略掉它，一起来看下没有注释的内容。# -*- mode: ruby -*-# vi: set ft=ruby :# All Vagrant configuration is done below. The \"2\" in Vagrant.configure# configures the configuration version (we support older styles for# backwards compatibility). Please don't change it unless you know what# you're doing.## vagrent 配置对应版本 2， 表示对应 2.X 的版本。Vagrant.configure(\"2\") do |config| # The most common configuration options are documented and commented below. # For a complete reference, please see the online documentation at # https://docs.vagrantup.com. # Every Vagrant development environment requires a box. You can search for # boxes at https://vagrantcloud.com/search. ## 当前使用的box config.vm.box = \"ubuntu/bionic64\" # Disable automatic box update checking. If you disable this, then # boxes will only be checked for updates when the user runs # `vagrant box outdated`. This is not recommended. # config.vm.box_check_update = false # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine. In the example below, # accessing \"localhost:8080\" will access port 80 on the guest machine. # NOTE: This will enable public access to the opened port # config.vm.network \"forwarded_port\", guest: 80, host: 8080 # Create a forwarded port mapping which allows access to a specific port # within the machine from a port on the host machine and only allow access # via 127.0.0.1 to disable public access # config.vm.network \"forwarded_port\", guest: 80, host: 8080, host_ip: \"127.0.0.1\" # Create a private network, which allows host-only access to the machine # using a specific IP. # config.vm.network \"private_network\", ip: \"192.168.33.10\" # Create a public network, which generally matched to bridged network. # Bridged networks make the machine appear as another physical device on # your network. # config.vm.network \"public_network\" # Share an additional folder to the guest VM. The first argument is # the path on the host to the actual folder. The second argument is # the path on the guest to mount the folder. And the optional third # argument is a set of non-required options. # config.vm.synced_folder \"../data\", \"/vagrant_data\" # Provider-specific configuration so you can fine-tune various # backing providers for Vagrant. These expose provider-specific options. # Example for VirtualBox: # # config.vm.provider \"virtualbox\" do |vb| # # Display the VirtualBox GUI when booting the machine # vb.gui = true # # # Customize the amount of memory on the VM: # vb.memory = \"1024\" # end # # View the documentation for the provider you are using for more # information on available options. # Enable provisioning with a shell script. Additional provisioners such as # Ansible, Chef, Docker, Puppet and Salt are also available. Please see the # documentation for more information about their specific syntax and use. # config.vm.provision \"shell\", inline: &lt;&lt;-SHELL # apt-get update # apt-get install -y apache2 # SHELLend 精简以后得到： 12345## vagrent 配置对应版本 2， 表示对应 2.X 的版本。Vagrant.configure(\"2\") do |config| ## 当前使用的box config.vm.box = \"ubuntu/bionic64\"end 三、启动123vagrant up# 启动的时候会下载box，可能非常慢。请耐心等待。如果失败请多次尝试。 四、登陆1234567891011121314151617181920212223vagrant ssh# Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-76-generic x86_64)# * Documentation: https://help.ubuntu.com# * Management: https://landscape.canonical.com# * Support: https://ubuntu.com/advantage# System information as of Thu Feb 13 09:01:34 UTC 2020# System load: 0.0 Processes: 97# Usage of /: 14.6% of 9.63GB Users logged in: 0# Memory usage: 19% IP address for enp0s3: 10.0.2.15# Swap usage: 0%# 0 packages can be updated.# 0 updates are security updates.# *** System restart required ***# Last login: Thu Feb 13 08:52:29 2020 from 10.0.2.2# vagrant@ubuntu-bionic:~$ 然后就像操作自己安装的虚拟机一样去操作机器就可以了。 常用命令box 显示本地的所有box 1vagrant box list 添加box 1vagrant box add box-name(box-url) 更新本地box 1vagrant box update box-name 删除本地box 1vagrant box remove box-name 重新打包本地box 1vagrant box repackage box-name 查找在线box 官方网站： https://app.vagrantup.com/boxes/search 基本命令 初始化 1vagrant init [box-name] 启动虚拟机 1vagrant up ssh登陆虚拟机 1vagrant ssh 挂起虚拟机（休眠） 1vagrant suspend 重启虚拟机 1vagrant reload 关闭虚拟机 1vagrant halt 查看运行状态 1vagrant status 销毁虚拟机 1vagrant destroy 配置解析虚拟机配置 config.vm config.vm.box：配置虚拟机使用的box 1config.vm.box = \"ubuntu/bionic64\" config.vm.hostname：配置虚拟机主机名 1config.vm.hostname=\"server-master\" config.vm.synced_folder：除了默认的目录绑定外，还可以手动指定绑定 12# 第一个参数是宿主机的目录，第二个参数是虚拟机挂载的目录。 config.vm.synced_folder \"/home/wolferhua\", \"/home/www/\" config.vm.network：这是配置虚拟机网络 Vagrant的网络连接方式有三种： NAT : 缺省创建，用于让vm可以通过host转发访问局域网甚至互联网。 host-only : 只有主机可以访问vm，其他机器无法访问它。 bridge : 此模式下vm就像局域网中的一台独立的机器，可以被其他机器访问。 12345678910111213# Host-only模式config.vm.network \"private_network\", ip: \"192.168.10.12\" # Bridge模式config.vm.network \"public_network\", ip: \"10.1.2.3\"#配置当前vm的host-only网络的IP地址为192.168.33.10config.vm.network :private_network, ip: \"192.168.33.10\"#host-only 模式的IP可以不指定，而是采用dhcp自动生成的方式，如 :config.vm.network \"private_network\", type: \"dhcp” 端口转发： 123456789config.vm.network :forwarded_port, guest: 80, host: 8080# 上面的配置把宿主机上的8080端口映射到客户虚拟机的80端口，例如你在虚拟机上使用nginx跑了一个Go应用，那么你在host上的浏览器中打开http://localhost:8080时，Vagrant就会把这个请求转发到虚拟机里跑在80端口的nginx服务上。不建议使用该方法，因为涉及端口占用问题，常常导致应用之间不能正常通信，建议使用Host-only和Bridge方式进行设置。# guest和host是必须的，还有几个可选属性：# ● guest_ip：字符串，vm指定绑定的Ip，缺省为0.0.0.0# ● host_ip：字符串，host指定绑定的Ip，缺省为0.0.0.0# ● protocol：字符串，可选TCP或UDP，缺省为TCP vm 节点配置(一个节点就是一个虚拟机)1234567891011Vagrant.configure(\"2\") do |config| config.vm.define \"web\" do |web| web.vm.box = \"nginx\" end config.vm.define \"db\" do |db| db.vm.box = \"mysql\" endend 当定义了多主机之后，在使用vagrant命令的时候，就需要加上主机名，例如vagrant ssh web；也有一些命令，如果你不指定特定的主机，那么将会对所有的主机起作用，比如vagrant up；你也可以使用表达式指定特定的主机名，例如vagrant up /follower[0-9]/。 config.vm.provider 虚机容器提供者配置 123456789101112131415config.vm.provider :virtualbox do |vb| #指定vm-name，也就是virtualbox管理控制台中的虚机名称。如果不指定该选项会生成一个随机的名字，不容易区分。 vb.name = \"ubuntu1804\" # vagrant up启动时，是否自动打开virtual box的窗口，缺省为false vb.gui = false #指定vm内存，单位为MB vb.memory = \"1024\" #设置CPU个数 vb.cpus = 2end config.vm.provision 让vagrant在启动虚拟机的时候自动执行，我们可以通过这个配置在虚拟机第一次启动的时候进行一些安装配置,这样你就可以省去手动配置环境的时间了。 脚本何时会被执行: 第一次执行vagrant up命令 执行vagrant provision命令 执行vagrant reload –provision或者vagrant up –provision命令 你也可以在启动虚拟机的时候添加–no-provision参数以阻止脚本被执行 123456789101112131415161718192021222324252627282930313233343536# 启动时执行shellVagrant.configure(\"2\") do |config| # ... other configuration config.vm.provision \"shell\", inline: \"echo hello\"endVagrant.configure(\"2\") do |config| # ... other configuration config.vm.provision \"shell\", inline: &lt;&lt;SCRIPTecho I am provisioning... SCRIPTend# 另一种写法Vagrant.configure(\"2\") do |config| # ... other configuration config.vm.provision \"shell\" do |s| s.inline = \"echo hello\" endend# 为任务取一个名字， 启动时默认不执行# 通过命令 vagrant provision --provision-with bootstrap 可以调用Vagrant.configure(\"2\") do |config| config.vm.provision \"bootstrap\", type: \"shell\", run: \"never\" do |s| s.inline = \"echo hello\" endend# 脚本执行config.vm.provision \"shell\", path: \"script.sh\" ssh配置 config.ssh config.ssh.username：默认的用户是vagrant，从官方下载的box往往使用的是这个用户名。如果是自定制的box，所使用的用户名可能会有所不同，通过这个配置设定所用的用户名。 批量配置123456789101112131415161718192021# 定义一组服务器app_servers = &#123; :service1 =&gt; '192.168.33.20', :service2 =&gt; '192.168.33.21'&#125;Vagrant.configure(\"2\") do |config| #遍历app_servers map，将key和value分别赋值给app_server_name和app_server_ip app_servers.each do |app_server_name, app_server_ip| #针对每一个app_server_name，来配置config.vm.define配置节点，命名为app_config config.vm.define app_server_name do |app_config| # 此处配置，参考config.vm.define end end end 也可以用下边的方案，不定义服务器。 12345678(1..3).each do |i| config.vm.define \"app-#&#123;i&#125;\" do |node| app_config.vm.hostname = \"app-#&#123;i&#125;\" app_config.vm.provider \"virtualbox\" do |vb| vb.name = app-#&#123;i&#125; end endend 修改完Vagrantfile的配置后，记得要重启虚拟机，才能使用虚拟机更新后的配置。 1vagrant reload","categories":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/categories/linux/"},{"name":"vagrant","slug":"linux/vagrant","permalink":"https://wolferhua.github.io/categories/linux/vagrant/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"vagrant","slug":"vagrant","permalink":"https://wolferhua.github.io/tags/vagrant/"}]},{"title":"Go-Micro学习笔记 - 4.5 MicroAPI 之 meta*","slug":"go-micro-book4-5","date":"2020-02-12T06:47:44.000Z","updated":"2020-02-12T06:47:44.589Z","comments":true,"path":"2020/02/12/go-micro-book4-5/","link":"","permalink":"https://wolferhua.github.io/2020/02/12/go-micro-book4-5/","excerpt":"","text":"meta，并无此模式，只是对api、rpc、proxy、web等模式的扩展使用方法. 既然是在对api、rpc、proxy、web等模式进行拓展，所以我们就对之前的api进行一次改造。 编写Meta改造部分代码12345678910111213141516171819202122// 只需改造注册处理器的代码。api1.RegisterApi1Handler(service.Server(), new(handler.Api1), api.WithEndpoint( &amp;api.Endpoint&#123; // 接口方法，一定要在proto接口中存在，不能是类的自有方法 Name: \"Api1.Get\", // 该接口使用的API转发模式 Handler: rpc.Handler, // 支持的请求方法 Method: []string&#123;\"GET\"&#125;, // http请求路由 Path: []string&#123;\"/api1\"&#125;, &#125;), api.WithEndpoint( &amp;api.Endpoint&#123; Name: \"Api1.Post\", Handler: rpc.Handler, Host: nil, Method: []string&#123;\"POST\"&#125;, Path: []string&#123;\"/api1\"&#125;, &#125;),) 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package mainimport ( \"gitee.com/wolferhua/go-micro-demo/demo001/meta1/handler\" \"gitee.com/wolferhua/go-micro-demo/demo001/meta1/proto/api1\" \"github.com/micro/go-micro/v2/api\" \"github.com/micro/go-micro/v2/api/handler/rpc\" micro \"github.com/micro/go-micro/v2\" \"github.com/micro/go-micro/v2/util/log\")func main() &#123; // 创建新服务 service := micro.NewService( micro.Name(\"com.anycps.wolferhua.api.api1\"), ) // 初始化 service.Init() // 只需改造注册处理器的代码。 api1.RegisterApi1Handler(service.Server(), new(handler.Api1), api.WithEndpoint( &amp;api.Endpoint&#123; // 接口方法，一定要在proto接口中存在，不能是类的自有方法 Name: \"Api1.Get\", // 该接口使用的API转发模式 Handler: rpc.Handler, // 支持的请求方法 Method: []string&#123;\"GET\"&#125;, // http请求路由 Path: []string&#123;\"/api1\"&#125;, &#125;), api.WithEndpoint( &amp;api.Endpoint&#123; Name: \"Api1.Post\", Handler: rpc.Handler, Host: nil, Method: []string&#123;\"POST\"&#125;, Path: []string&#123;\"/api1\"&#125;, &#125;), ) // 执行服务 if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 运行启动服务因为我们在api中调用了服务，所以需要启动它，如果你在操作时省去了服务调用环节，可以不用启动它，不是必须的。 12cd srv1 go run main.go 启动网关网关的概念，上一张我们讲到过，不清楚的可以看一下：Go-Micro学习笔记 - 4. MicroAPI(API网关) 123456micro api --namespace com.anycps.wolferhua.api --handler api# 2020-02-05 17:44:31 [api] Registering API Default Handler at /# 2020-02-05 17:44:31 [api] HTTP API Listening on [::]:8080# 2020-02-05 17:44:31 [api] Starting [service] go.micro.api# 2020-02-05 17:44:31 [api] Server [grpc] Listening on [::]:33951 参数解释： –namespace： 指定命名空间，只有在这个命名空间以内的服务才可以被访问。 –handler： 指定服务类型，这里指定的是api,上一章我们讲过handler的类型。 启动api123456cd api1go run main.go# 2020-02-05 17:03:23 Starting [service] com.anycps.wolferhua.api.api1# 2020-02-05 17:03:23 Server [grpc] Listening on [::]:43785# 2020-02-05 17:03:23 Registry [mdns] Registering node: com.anycps.wolferhua.api.api1-3c0fd6b3-9e19-4c4b-ba12-a217ee15492c 验证查看服务列表1234micro list services # com.anycps.wolferhua.api.api1 # api 服务# com.anycps.wolferhua.srv1 # 服务# go.micro.api # 网关 访问api1234567891011121314# 原始调用方式curl 'http://localhost:8080/api1/get?name=wolferhua' ###### 新指定路由调用方式 ######curl 'http://localhost:8080/api1?name=wolferhua'# &#123;\"message\":\"我们已经收到你的请求，Hello wolferhua ,from pid 10086\"&#125;# 原始调用方式curl http://localhost:8080/api1 -X POST -H 'Content-Type: application/json' -d '&#123;\"name\":\"wolferhua\"&#125;'###### 新指定路由调用方式 ######curl http://localhost:8080/api1/post -X POST -H 'Content-Type: application/json' -d '&#123;\"name\":\"wolferhua\"&#125;'# 收到消息：&#123;\"name\":\"wolferhua\"&#125;","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Go-Micro学习笔记 - 4.4 MicroAPI 之 event","slug":"1go-micro-book4-4","date":"2020-02-10T11:30:59.000Z","updated":"2020-02-11T09:35:09.990Z","comments":true,"path":"2020/02/10/1go-micro-book4-4/","link":"","permalink":"https://wolferhua.github.io/2020/02/10/1go-micro-book4-4/","excerpt":"","text":"event API会把http请求映射到匹配的事件处理服务上. 编写Event服务端event1/main.goview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package mainimport ( \"context\" \"github.com/micro/go-micro/v2\" proto \"github.com/micro/go-micro/v2/api/proto\" \"github.com/micro/go-micro/v2/util/log\")// 切记，事件订阅结构的所有公有方法都会被执行，方法名没有限制，但是方法一定要接收ctx，eventtype Event1 struct{}func (e *Event1) Handler(ctx context.Context, event *proto.Event) error { log.Info( \"公有方法Handler Id，\", event.Id) log.Log(\"公有方法Handler 收到事件，\", event.Name) log.Log(\"公有方法Handler 数据\", event.Data) return nil}func (e *Event1) Handler1(ctx context.Context, event *proto.Event) error { log.Info( \"公有方法Handler1 Id，\", event.Id) log.Log(\"公有方法Handler1 收到事件，\", event.Name) log.Log(\"公有方法Handler1 数据，\", event.Data) return nil}/**打开本注释后，会导致侦听器无法工作。方法一定要接收ctx，event才能正常运行。func (e *Event1) Handler2() error { log.Log(\"公有方法Handler2 收到事件，不解析参数\") return nil}**/func (e *Event1) handler(ctx context.Context, event *proto.Event) error { log.Log(\"私有方法 handler，收到事件，\", event.Name) log.Log(\"私有方法 handler，数据\", event.Data) return nil}func main() { service := micro.NewService( // 服务名可以随意 micro.Name(\"event1\"), // 在event 处理器里边关注的是 topic 的名称，服务名称不用在意。 ) service.Init() // 订阅事件 micro.RegisterSubscriber(\"com.anycps.wolferhua.api.event1\", service.Server(), new(Event1)) if err := service.Run(); err != nil { log.Fatal(err) }} 运行123456# mod 操作go mod initgo mod tidy# 运行go run main.go 我们监听的事件是: com.anycps.wolferhua.api.event1,所以我们需要使用--namespace com.anycps.wolferhua.api，这里的名称和micro.Name(&quot;event1&quot;)无关。 12# APImicro api --namespace com.anycps.wolferhua.api --handler event 测试结果12345678 curl http://localhost:8080/web1/get# ========== 服务端日志输出。=================# 2020-02-11 17:17:03 com.anycps.wolferhua.api.web1-get-0caa89fe-7d1a-4e1f-b058-ae7fb5d11ece# 2020-02-11 17:17:03 公有方法Process2 收到事件，get# 2020-02-11 17:17:03 公有方法Process 收到事件，get# 2020-02-11 17:17:03 公有方法Process 数据&#123;&#125;# 2020-02-11 17:17:03 公有方法Process2 数据，&#123;&#125; 总结总的来说event和rpc、api，有些相似。我们来对比下 api 需要定义每一个服务名称对应的方法和参数，event可以通过事件名称获取。比如上边的方法名可以理解为Event1.Get。 api 每一个服务只有一个响应方法，event 可以有多个。 api 可以响应返回数据，event 不可以。所以event 可以用作一些无需要返回数据的业务，如日志提交接口。 其他差异需要你们细细去对比了。","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Go-Micro学习笔记 - 4.3 MicroAPI 之 web 、http","slug":"2go-micro-book4-3","date":"2020-02-10T11:30:59.000Z","updated":"2020-02-11T09:35:13.750Z","comments":true,"path":"2020/02/10/2go-micro-book4-3/","link":"","permalink":"https://wolferhua.github.io/2020/02/10/2go-micro-book4-3/","excerpt":"","text":"经过之前的学习，我们已经学会了api,rpc处理器的开发。但是使用发现，这两种处理器是一对一注册的，路由配置比较麻烦（mate*处理器的时候讲）。所以我们今天将回到我们之前的开发模式来开发服务。 web和http都具有相同的能力，但是http不支持转发websocket。 编写Web服务端代码web1/main.goview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package mainimport ( \"encoding/json\" \"net/http\" \"net/url\" \"strings\" \"github.com/gorilla/websocket\" \"github.com/micro/go-micro/v2\" \"github.com/micro/go-micro/v2/transport/grpc\" \"github.com/micro/go-micro/v2/util/log\" \"github.com/micro/go-micro/v2/web\")// websocket 服务var upgrader = websocket.Upgrader{CheckOrigin: func(r *http.Request) bool { return true}}var sysName = `系统通知：`// 消息列表type Message struct { Code int `json:\"code\"` Name string `json:\"name\"` Type int `json:\"type\"` Message string `json:\"message\"`}var messages = make(chan *Message, 100)// 链接列表var connections = map[string]*websocket.Conn{}func main() { // 这里使用的是go-micro web 包，因为它已经实现了服务注册，和发现的能力。不需要我们再去处理了。 service := web.NewService( web.Name(\"com.anycps.wolferhua.api.web1\"), web.MicroService(micro.NewService(micro.Transport(grpc.NewTransport()))), ) service.Options().Service.Client() // 初始化服务 if err := service.Init(); err != nil { log.Fatal(\"Init\", err) } // 路由注册 // 注册静态资源目录（页面） service.Handle(\"/web1/\", http.StripPrefix(\"/web1/\", http.FileServer(http.Dir(\"html\")))) // 注册websocket监听（socket） service.HandleFunc(\"/web1/ws\", ws) // 获取用户列表接口（接口） service.HandleFunc(\"/web1/ws/users\", users) go wsSend() // 启动服务 if err := service.Run(); err != nil { log.Fatal(\"Run: \", err) }}// 获取用户列表接口func users(w http.ResponseWriter, r *http.Request) { // 读取列表 list := make([]string, 0, len(connections)) for name, _ := range connections { list = append(list, name) } // 返回数据 w.Header().Add(\"Content-Type\", \"application/json; charset=utf-8\") w.WriteHeader(200) data, _ := json.Marshal(list) w.Write(data)}// websocket 服务func ws(w http.ResponseWriter, r *http.Request) { vals, err := url.ParseQuery(r.URL.RawQuery) name := strings.TrimSpace(vals.Get(\"name\")) //fmt.Println(vals.Get(\"name\")) c, err := upgrader.Upgrade(w, r, nil) if err != nil { log.Errorf(\"upgrade: %s\", err) return } // 退出 defer c.Close() // 判断内容 if len(name) &lt; 1 { // 返回错误信息 // http.Error(w, `{\"code\":500,\"message\":\"请输入名称！\"}`, 500) c.WriteMessage(websocket.TextMessage, []byte(`{\"code\":500,\"message\":\"请输入名称！\"}`)) return } // 验证重复状态 if _, ok := connections[name]; ok { // 返回错误信息 // http.Error(w, `{\"code\":500,\"message\":\"请输入名称！\"}`, 500) c.WriteMessage(websocket.TextMessage, []byte(`{\"code\":501,\"message\":\"名称已经存在了！\"}`)) return } defer func() { // 退出客户列表 delete(connections, name) messages &lt;- &amp;Message{Type: websocket.TextMessage, Code: 119, Name: sysName, Message: ` ` + name + ` 退出了 `} // 关闭链接 c.Close() }() connections[name] = c messages &lt;- &amp;Message{Type: websocket.TextMessage, Code: 120, Name: sysName, Message: ` ` + name + ` 上线了 `} for { // 读取消息 mt, message, err := c.ReadMessage() if err != nil { log.Error(\"read:\", err) break } log.Errorf(\"recv: %s\", message) // 写入消息列表 messages &lt;- &amp;Message{Name: name, Code: 200, Type: mt, Message: string(message)} }}// 消息消费func wsSend() { // 读取消息 for message := range messages { // 遍历发给所有人。 for name, conn := range connections { if conn != nil { err := conn.WriteJSON(message) if err != nil { log.Error(\"send to \", name, \"err :\", err) } } } }} 前端界面htmlweb1/html/index.htmlview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;!-- Required meta tags --&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;!-- Bootstrap CSS --&gt; &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css\" integrity=\"sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh\" crossorigin=\"anonymous\"&gt; &lt;title&gt;Go Web1&lt;/title&gt; &lt;style&gt; body { padding-top: 100px; } .main-body &gt; .row { margin-top: 30px; margin-bottom: 30px; } .message-box{ padding: 30px; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"container-xl main-body border\"&gt; &lt;div class=\"row message-row\"&gt; &lt;div class=\"col \"&gt; &lt;!--消息显示框框--&gt; &lt;div class=\"container-fluid border message-box\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;p class=\"text-muted text-center\"&gt;欢迎使用。&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-2 border\"&gt; &lt;h1&gt;在线用户列表：&lt;/h1&gt; &lt;ul class=\"list-group user-list\"&gt; &lt;!--显示用户列表--&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row \"&gt; &lt;div class=\"col\"&gt; &lt;!--消息输入框--&gt; &lt;textarea class=\"form-control\" id=\"message\" rows=\"3\"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col\"&gt; &lt;!--发送按钮--&gt; &lt;button type=\"submit\" id=\"send-but\" class=\"btn btn-primary\"&gt;Send&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;!-- Optional JavaScript --&gt;&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js\" integrity=\"sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\" integrity=\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/js/bootstrap.min.js\" integrity=\"sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/lodash@4.17.15/lodash.min.js\" integrity=\"sha256-VeNaFBVDhoX3H+gJ37DpT/nTuZTdjYro9yBruHjVmoQ=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"index.js\" type=\"application/javascript\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; javascriptweb1/html/index.jsview raw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//alert(\"message\")(function ($) { const sessionKey = 'name'; const host = window.location.host; const wsUrl = \"ws://\" + host + \"/web1/ws?name=\"; let $messageBox = $(\".message-box\"); //消息框 let $message = $(\"#message\"); //消息内容 let $sendBut = $(\"#send-but\"); //消息按钮 let $userList = $(\".user-list\");//用户列表 let ws = null; // 获取用户名称 let name = sessionStorage.getItem(sessionKey);// 如果存在 // 加载用户列表 let loadUserList = _.debounce(function () { //console.log($) $.ajax({ url:'/web1/ws/users', dataType:'json', success:function (ret) { //console.log(ret); // 渲染消息数据 let $warp = $('&lt;div&gt;&lt;/div&gt;'); for (let i in ret){ $warp.append('&lt;li class=\"list-group-item\" data-name=\"'+ret[i]+'\"&gt;'+ret[i]+'&lt;/li&gt;') } $userList.html($warp.html()); } }) },3000); // 显示消息 function writeMessage(content) { let item = $('&lt;div class=\"col\"&gt;&lt;/div&gt;'); item.html(content); writeMessageRow(item); } function writeMessageRow(content) { let item = $('&lt;div class=\"row\"&gt;&lt;/div&gt;'); item.html(content); $messageBox.append(item); } // 名称输入提示 function namePrompt() { // 没有存储名称。 do { name = window.prompt(\"请输入名称：\"); name = name.trim(); // 存入本地存储 sessionStorage.setItem(sessionKey, name); } while (!name) } // 链接服务器 function connectServer() { ws = new WebSocket(wsUrl + name); // 事件监听 ws.onopen = function (evt) { writeMessage('&lt;p class=\"text-success text-center\"&gt;与服务器链接已经建立。&lt;/p&gt;'); loadUserList(); }; ws.onclose = function (evt) { writeMessage('&lt;p class=\"text-danger text-center\"&gt;链接断开，请重新链接。&lt;/p&gt;'); ws = null; }; ws.onmessage = function (evt) { let data = JSON.parse(evt.data); if (!data || !data.code || !data.message) return; // 消息体不匹配 if (data.code &gt;= 500) { // 系统异常消息：退出，并关闭链接 sessionStorage.removeItem(sessionKey); writeMessage('&lt;p class=\"text-danger text-center\"&gt;' + data.message + '&lt;/p&gt;'); ws = null; return; } if (data.code &gt;= 200) { // 用户消息。显示消息内容 var message = ''; if (data.name == name) { //本人发送消息 message += '&lt;div class=\"col-auto\"&gt;&lt;p class=\"text-success\"&gt;' + data.name + '&lt;/p&gt;&lt;/div&gt;' } else { //其他人发送消息 message += '&lt;div class=\"col-auto\"&gt;&lt;p class=\"text-muted\"&gt;' + data.name + '&lt;/p&gt;&lt;/div&gt;' } message += '&lt;div class=\"col\"&gt;' + data.message + '&lt;/div&gt;'; writeMessageRow(message); return; } // 系统通知消息 if (data.code &gt;= 100) { writeMessage('&lt;p class=\"text-muted text-center\"&gt;' + data.message + '&lt;/p&gt;'); loadUserList(); return; } }; ws.onerror = function (evt) { writeMessage('&lt;p class=\"text-danger text-center\"&gt;服务器错误，请重新链接。&lt;/p&gt;'); ws = null; }; } // 节流函数，防止重复点击。 let send = _.debounce(function () { var content = $message.val().trim(); if (!content) { alert('请输入内容！'); return; } if (ws == null) { namePrompt(); connectServer(); } ws.send(content); $message.val(''); $message.focus(); }, 200); // 回车键发送消息 $message.keypress(function (event) { if (event.keyCode === 13) { // 阻止事件冒泡 if (event.preventDefault) event.preventDefault; event.returnValue = false; // 发送消息 send(); return false; } }); // 按钮发送 $sendBut.click(send); // 开始连接。 if (name) { connectServer(); } else { namePrompt(); connectServer(); }})(jQuery); 运行代码12345# mod 操作go mod initgo mod tidy# 运行go run main.go 12# APImicro api --namespace com.anycps.wolferhua.api --handler web 运行效果","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Go-Micro学习笔记 - 4.2 MicroAPI 之 rpc","slug":"go-micro-book4-2","date":"2020-02-06T09:19:22.000Z","updated":"2020-03-18T02:10:25.489Z","comments":true,"path":"2020/02/06/go-micro-book4-2/","link":"","permalink":"https://wolferhua.github.io/2020/02/06/go-micro-book4-2/","excerpt":"","text":"rpc 处理器通过RPC向go-micro应用转送请求，只接收GET和POST请求，GET转发RawQuery，POST转发Body。rpc 几乎和api一致，区别就在于是否会传递http请求头信息和请求类型的限制。 编写API 我的目录结构大概是这样的。之后的操作我们都是基于 $GOPATH/src/gitee.com/wolferhua/go-micro-demo/demo001 目录里边的相对路径。后边就不赘述了。 定义APIrpc1/proto/rpc1/rpc1.proto 1234567891011syntax = \"proto3\";// 偷个懒，就不定义request 和 response 结构了，直接应用服务端的定义。import \"gitee.com/wolferhua/go-micro-demo/demo001/rpc1/proto/srv1/srv1.proto\";// 定义新服务，service Rpc1 &#123; rpc Say(HelloRequest) returns (HelloResponse) &#123;&#125;&#125;// protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. rpc1.proto 如果不太清楚参考: Protobuf 语言指南（proto3） 三、编写Handler查看上边生成的内容，可以知道api的interface定义如下。 rpc1/proto/rpc1/rpc1.pb.micro.go 123type Rpc1Handler interface &#123; Say(context.Context, *srv1.HelloRequest, *srv1.HelloResponse) error&#125; 编写代码rpc1/handler/rpc1.go 1234567891011121314151617181920212223242526272829303132333435363738package handlerimport ( \"context\" \"gitee.com/wolferhua/go-micro-demo/demo001/rpc1/proto/srv1\" \"gitee.com/wolferhua/go-micro-demo/demo001/rpc1/srv\" \"github.com/micro/go-micro/v2/util/log\")type Rpc1 struct &#123;&#125;// Rpc1.Get 通过API向外暴露为/rpc1/get，接收http请求// 即：/rpc1/get请求会调用 com.anycps.wolferhua.api.rpc1 服务的 Rpc1.Get方法// curl 'http://localhost:8080/rpc1/say' -X POST -H 'Content-Type: application/json' -d '&#123;\"name\":\"wolferhua\"&#125;'func (a *Rpc1) Say(ctx context.Context, in *srv1.HelloRequest, out *srv1.HelloResponse) error &#123; log.Log(\"Rpc1.Say接口收到请求\") // 调用服务,其目的是达到服务相互调用的效果演示。 rep, err := srv.Srv1(in.Name) if err != nil &#123; log.Error(\"服务端响应失败:\" + err.Error()) return nil //errors.InternalServerError(\"com.anycps.wolferhua.api.rpc1\", \"服务端响应失败:\"+err.Error()) &#125; // 返回数据 out.Greeting = \"srv1 response : \" + rep return nil&#125;// 其他方法，无法被api调用func (a *Rpc1) Test() &#123; log.Log(\"Rpc1.Test接口收到请求\")&#125; 四、main.go12345678910111213141516171819202122232425package mainimport ( \"gitee.com/wolferhua/go-micro-demo/demo001/rpc1/handler\" \"gitee.com/wolferhua/go-micro-demo/demo001/rpc1/proto/rpc1\" micro \"github.com/micro/go-micro/v2\" \"github.com/micro/go-micro/v2/util/log\")func main() &#123; // 创建新服务 service := micro.NewService( micro.Name(\"com.anycps.wolferhua.api.rpc1\"), ) // 初始化 service.Init() // 注册处理器 rpc1.RegisterRpc1Handler(service.Server(), new(handler.Rpc1)) // 执行服务 if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 五、测试123curl 'http://localhost:8080/rpc1/say' -X POST -H 'Content-Type: application/json' -d '&#123;\"name\":\"wolferhua\"&#125;'# &#123;\"greeting\":\"srv1 response : Hello wolferhua ,from pid 10086\"&#125;","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Protobuf 语言指南（proto3）","slug":"protobuf","date":"2020-02-06T06:41:29.000Z","updated":"2020-03-18T02:10:25.489Z","comments":true,"path":"2020/02/06/protobuf/","link":"","permalink":"https://wolferhua.github.io/2020/02/06/protobuf/","excerpt":"","text":"什么是Protobufprotocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于通信协议、数据存储等。 为什么要用？难道json、xml它不香么？香！但是我们来看一个对比图。 浏览器中运行 压缩环境下Protobuf和JSON的结果非常相似。Protobuf消息比JSON消息小9％，减少了4%的时间。这听起来像什么都没有，但考虑到浏览器端Protobuf必须从二进制转换为JSON（JavaScript代码使用JSON作为其对象文字格式) - 令人惊讶的速度。好像看不出太大区别？别急接着看。 java 性能提升非常明显。在非压缩环境中使用Protobuf时，请求所花费的时间比JSON请求少78％。 这表明二进制格式的执行速度几乎是文本格式的5倍。在压缩环境中发出这些请求时，差异甚至更大。Protobuf执行速度提高了6倍，仅需25ms即可处理JSON格式需要150ms处理的请求。 正如您所看到的，当JSON不是native环境(如NodeJS,浏览器)时，性能提升的非常大。 因此，当您遇到JSON的延迟问题时，请考虑迁移到Protobuf。 优缺点从上边对比我们可以看到： 小 5 倍 快 6 倍 如果是和xml对比，这个更加数值更加可观： 小 3 ~ 10 倍 快 20 ~ 100 倍 测试使用的结构非常小，如果再大点这个数值会更加可观。 那它有缺点么？当然！ 缺点 缺少详细的文档。关于使用和开发Protobuf，你不会找到那么多的文档。 较小的社区。 例如，在Stack Overflow上，您会发现大约有1500个标有Protobuf标签的问题，而JSON却有超过18万个 缺乏支持。 Google不支持如Swift，R，Scala等的编程语言。但是，您可以通过第三方库解决此问题，例如Apple提供的Swift Protobuf。 可读性不高。 JSON以文本格式交换，结构简单，易于人类阅读和分析。 自定义protobuf的工作量偏大 虽然选择Protobuf会带来这些缺点，但在某些情况下，这个消息格式要快得多。与JSON相比，具有预定义和更大的数据类型集，在Protobuf上序列化的消息可以由负责交换它们的代码自动验证。 他还有一些其他优点： 格式规范。 支持rpc。 结构校验。 安装12345678910111213141516171819202122232425go get github.com/micro/protobuf/&#123;proto,protoc-gen-go&#125;go get github.com/micro/protoc-gen-micro/v2## protoc 安装#### LINUX ###wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-linux-x86_64.zip -O $GOPATH/protoc.zip#### Mac OS ###wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-osx-x86_64.zip -O $GOPATH/protoc.zip## 解压unzip $GOPATH/protoc.zip -d $GOPATH/protoccp $GOPATH/protoc/bin/protoc $GOPATH/bin# 安装完成测试protoc --version# libprotoc 3.11.3 protoc 使用123456# Usage: protoc [OPTION] PROTO_FILESprotoc --proto_path=$GOPATH/src:. --go_out=. user.proto# 解释# --proto_path=$GOPATH/src:. #指定搜索目录为 $GOPATH/src 和 .（当前目录）# --go_out=. #生成go文件到当前目录# user.proto #proto 文件 参数解析 –proto_path=PATH 指定文件搜索目录 –cpp_out=OUT_DIR 生成 C++ header and source. –csharp_out=OUT_DIR 生成 C# source file. –java_out=OUT_DIR 生成 Java source file. –js_out=OUT_DIR 生成 JavaScript source. –objc_out=OUT_DIR 生成 Objective C header and source. –php_out=OUT_DIR 生成 PHP source file. –python_out=OUT_DIR 生成 Python source file. –ruby_out=OUT_DIR 生成 Ruby source file. –micro_out=OUT_DIR 生成 Go-micro source file. 编写Protobuf一下代码目录结构 12345678910111213test1├── main.go└── proto ├── company │ ├── department.pb.go │ ├── department.proto │ ├── user.pb.go │ └── user.proto ├── school │ ├── school.pb.go │ └── school.proto ├── user.pb.go └── user.proto 基础语法用户定义 部门定义 数据类型这里直接引用官方文档的描述： .proto C++ Java Python Go Ruby C# double double double float float64 Float double float float float float float32 Float float int32 int32 int int int32 Fixnum or Bignum int int64 int64 long ing/long[3] int64 Bignum long uint32 uint32 int[1] int/long[3] uint32 Fixnum or Bignum uint uint64 uint64 long[1] int/long[3] uint64 Bignum ulong sint32 int32 int intj int32 Fixnum or Bignum int sint64 int64 long int/long[3] int64 Bignum long fixed32 uint32 int[1] int uint32 Fixnum or Bignum uint fixed64 uint64 long[1] int/long[3] uint64 Bignum ulong sfixed32 int32 int int int32 Fixnum or Bignum int sfixed64 int64 long int/long[3] int64 Bignum long bool bool boolean boolean bool TrueClass/FalseClass bool string string String str/unicode[4] string String(UTF-8) string bytes string ByteString str []byte String(ASCII-8BIT) ByteString 默认值解析消息时，如果编码消息不包含特定的单数元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是特定于类型的： 对于字符串，默认值为空字符串。 对于字节，默认值为空字节。 对于bools，默认值为false。 对于数字类型，默认值为零。 对于枚举，默认值是第一个定义的枚举值，该值必须为0。 对于消息字段，未设置该字段。它的确切值取决于语言。有关详细信息， 请参阅生成的代码指南; 重复字段的默认值为空（通常是相应语言的空列表）。 生成文件 示例代码 定义服务定义 生成 嵌套使用定义 生成 代码地址代码目录","categories":[{"name":"protobuf","slug":"protobuf","permalink":"https://wolferhua.github.io/categories/protobuf/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"},{"name":"protobuf","slug":"protobuf","permalink":"https://wolferhua.github.io/tags/protobuf/"}]},{"title":"Go-Micro学习笔记 - 4.1 MicroAPI 之 api","slug":"go-micro-book4.1","date":"2020-02-05T09:55:09.000Z","updated":"2020-03-18T02:10:25.489Z","comments":true,"path":"2020/02/05/go-micro-book4.1/","link":"","permalink":"https://wolferhua.github.io/2020/02/05/go-micro-book4.1/","excerpt":"","text":"通过之前的学习，我们已经知道了如何编写服务，并且了解到了API网关。接下来我们将学习如何编写API的处理器，我们先从我们最熟悉的api开始。 api 处理器通过RPC向go-micro应用转送请求，会把完整的http头封装向下传送，不限制请求方法。 编写API 我的目录结构大概是这样的。之后的操作我们都是基于 $GOPATH/src/gitee.com/wolferhua/go-micro-demo/demo001 目录里边的相对路径。后边就不赘述了。 一、定义API定义api接口的APIapi1/proto/api1/api1.proto 12345678910syntax = \"proto3\";import \"github.com/micro/go-micro/api/proto/api.proto\";service Api1 &#123; // go.api.Request 和 go.api.Response 里边就封装了http相关的内容。 rpc Get(go.api.Request) returns(go.api.Response) &#123;&#125;; rpc Post(go.api.Request) returns(go.api.Response) &#123;&#125;;&#125; 定义srv接口API 这个是我们之前编写服务的定义，如有疑惑请看前面章节。 api1/proto/srv1/srv1.proto 12345678910111213syntax = \"proto3\";service Srv1 &#123; rpc Hello(HelloRequest) returns (HelloResponse) &#123;&#125;&#125;message HelloRequest &#123; string name = 1;&#125;message HelloResponse &#123; string greeting = 2;&#125; 二、生成API123456789101112131415161718192021# api cd api1/proto/api1protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. api1.proto# srvcd api1/proto/srv1protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. srv1.proto## 目录结构# proto# ├── api1# │ ├── api1.pb.go# │ ├── api1.pb.micro.go# │ └── api1.proto# └── srv1# ├── srv1.pb.go# ├── srv1.pb.micro.go# └── srv1.prot 三、编写HandlerAPI定义查看查看上边生成的内容，可以知道api的interface定义如下。 api1/proto/api1/api1.pb.micro.go:77 1234type Api1Handler interface &#123; Get(context.Context, *proto1.Request, *proto1.Response) error Post(context.Context, *proto1.Request, *proto1.Response) error&#125; 编写代码api1/handler/api1.go 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package handlerimport ( \"context\" \"encoding/json\" \"strings\" \"gitee.com/wolferhua/go-micro-demo/demo001/api1/srv\" proto1 \"github.com/micro/go-micro/api/proto\" \"github.com/micro/go-micro/v2/errors\" \"github.com/micro/go-micro/v2/util/log\")type Api1 struct &#123;&#125;// Api1.Get 通过API向外暴露为/api1/get，接收http请求// 即：/api1/get请求会调用com.anycps.wolferhua.api.api1服务的Api1.Get方法//curl 'http://localhost:8080/api1/get?name=wolferhua'func (a *Api1) Get(ctx context.Context, in *proto1.Request, out *proto1.Response) error &#123; log.Log(\"Api1.Get接口收到请求\") name, ok := in.Get[\"name\"] if !ok || len(name.Values) == 0 &#123; return errors.BadRequest(\"com.anycps.wolferhua.api.api1\", \"参数不正确\") &#125; // 打印请求头 for k, v := range in.Header &#123; log.Log(\"请求头信息，\", k, \" : \", v) &#125; out.StatusCode = 200 // 调用服务,其目的是达到服务相互调用的效果演示。 sname := strings.Join(name.Values, \"\") srvRsp, err := srv.Srv1(sname) if err != nil &#123; return errors.InternalServerError(\"com.anycps.wolferhua.api.api1\", \"服务端响应失败:\"+err.Error()) &#125; // 业务代码 b, _ := json.Marshal(map[string]string&#123; \"message\": \"我们已经收到你的请求，\" + srvRsp, &#125;) // 设置返回值 out.Body = string(b) return nil&#125;// Api1.Post 通过API向外暴露为/api1/get，接收http请求// 即：/api1/post请求会调用com.anycps.wolferhua.api.api1服务的Api1.Post方法// curl http://localhost:8080/api1/post -X POST -H 'Content-Type: application/json' -d '&#123;\"name\":\"wolferhua\"&#125;'func (a *Api1) Post(ctx context.Context, in *proto1.Request, out *proto1.Response) error &#123; log.Log(\"Api1.Post接口收到请求\") // 判断请求类型 if in.Method != \"POST\" &#123; return errors.BadRequest(\"com.anycps.wolferhua.api.api1\", \"require post\") &#125; // 获取请求头信息 ct, ok := in.Header[\"Content-Type\"] if !ok || len(ct.Values) == 0 &#123; return errors.BadRequest(\"com.anycps.wolferhua.api.api1\", \"need content-type\") &#125; // 判断请求头类型 if ct.Values[0] != \"application/json\" &#123; return errors.BadRequest(\"com.anycps.wolferhua.api.api1\", \"expect application/json\") &#125; // 获取请求数据 var body map[string]interface&#123;&#125; json.Unmarshal([]byte(in.Body), &amp;body) // 设置返回值 out.Body = \"收到消息：\" + string([]byte(in.Body)) return nil&#125;// 其他方法，无法被api调用func (a *Api1) Test() &#123; log.Log(\"Api1.Test接口收到请求\")&#125; 四、调用服务api1/srv/srv1.go 123456789101112131415161718192021222324252627282930package srvimport ( \"context\" \"log\" \"gitee.com/wolferhua/go-micro-demo/demo001/api1/proto/srv1\" \"github.com/micro/go-micro/v2\")func Srv1(name string) (string, error) &#123; service := micro.NewService() // 获取客户端对象 client := service.Client() // 创建srv1 客户端 srv1Client := srv1.NewSrv1Service(\"com.anycps.wolferhua.srv1\", client) // 在Srv1 handler上请求调用Hello方法 rsp, err := srv1Client.Hello(context.TODO(), &amp;srv1.HelloRequest&#123; Name: name, &#125;) if err != nil &#123; log.Fatal(err) return \"\", err &#125; // 返回服务端 return rsp.Greeting, nil&#125; 五、main.go1234567891011121314151617181920212223242526272829package mainimport ( \"gitee.com/wolferhua/go-micro-demo/demo001/api1/handler\" \"gitee.com/wolferhua/go-micro-demo/demo001/api1/proto/api1\" micro \"github.com/micro/go-micro/v2\" \"github.com/micro/go-micro/v2/util/log\")func main() &#123; // 创建新服务 service := micro.NewService( micro.Name(\"com.anycps.wolferhua.api.api1\"), ) // 细心的朋友可以发现：我们之前定义服务时使用的是：com.anycps.wolferhua.***， // 现在却使用：com.anycps.wolferhua.api.***。 // 因为我们会定义非常多的接口，需要一个统一的命名空间（Namespace）方便管理。 // 至于命名空间，我们之后会讲解,go-micro 中使用的非常多。 // 初始化 service.Init() // 注册处理器 api1.RegisterApi1Handler(service.Server(), new(handler.Api1)) // 执行服务 if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; 六、运行启动服务因为我们在api中调用了服务，所以需要启动它，如果你在操作时省去了服务调用环节，可以不用启动它，不是必须的。 12cd srv1 go run main.go 启动网关网关的概念，上一张我们讲到过，不清楚的可以看一下：Go-Micro学习笔记 - 4. MicroAPI(API网关) 123456micro api --namespace com.anycps.wolferhua.api --handler api# 2020-02-05 17:44:31 [api] Registering API Default Handler at /# 2020-02-05 17:44:31 [api] HTTP API Listening on [::]:8080# 2020-02-05 17:44:31 [api] Starting [service] go.micro.api# 2020-02-05 17:44:31 [api] Server [grpc] Listening on [::]:33951 参数解释： –namespace： 指定命名空间，只有在这个命名空间以内的服务才可以被访问。 –handler： 指定服务类型，这里指定的是api,上一章我们讲过handler的类型。 启动api123456cd api1go run main.go# 2020-02-05 17:03:23 Starting [service] com.anycps.wolferhua.api.api1# 2020-02-05 17:03:23 Server [grpc] Listening on [::]:43785# 2020-02-05 17:03:23 Registry [mdns] Registering node: com.anycps.wolferhua.api.api1-3c0fd6b3-9e19-4c4b-ba12-a217ee15492c 验证查看服务列表1234micro list services # com.anycps.wolferhua.api.api1 # api 服务# com.anycps.wolferhua.srv1 # 服务# go.micro.api # 网关 访问api1234567curl 'http://localhost:8080/api1/get?name=wolferhua'# &#123;\"message\":\"我们已经收到你的请求，Hello wolferhua ,from pid 10086\"&#125;curl http://localhost:8080/api1/post -X POST -H 'Content-Type: application/json' -d '&#123;\"name\":\"wolferhua\"&#125;'# 收到消息：&#123;\"name\":\"wolferhua\"&#125; 如此我们的api编写完成。 # 代码仓库 - [Api1代码](https://gitee.com/wolferhua/go-micro-demo/tree/master/demo001/api1)","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Go-Micro学习笔记 - 4. MicroAPI(API网关)","slug":"go-micro-book4","date":"2020-02-04T11:15:34.000Z","updated":"2020-02-10T11:07:12.020Z","comments":true,"path":"2020/02/04/go-micro-book4/","link":"","permalink":"https://wolferhua.github.io/2020/02/04/go-micro-book4/","excerpt":"","text":"Micro API Micro API是基于服务发现驱动开发的可插拔API框架，旨在帮助构建强大的 API网关。 API网关模式API网关模式 为服务提供了一个单一的公共入口。 之后的内容中简称：API,不要和api搞混了，api正对的是一个具体的实现，具体的业务接口。而 API 代表的始终具体的规范。为什么要这样呢？主要是为了更贴合官方文档，有可能我理解的不够准确。 API网关可以为每个客户端公开不同的API，而不是提供一个一刀切的API。 前端的后端API该模式的一个变体是前端模式的后端。它为每种客户端定义了一个单独的API网关。 在本例中，有三种客户端:web应用程序、移动应用程序和外部第三方应用程序。有三种不同的应用编程接口网关。每一个都为它的客户提供了一个应用编程接口。 Micro API通过服务发现，Micro API以http方式，将请求动态路由到具体的后台服务接口。 所以API本质上就一个服务网关，它具备动态路由、服务发现的能力，以HTTP方式把外界请求映射到本地微服务，以对外提供服务。 通过服务发现，配合内置的命名空间（Namespace）【我们之后会讲解go-micro 中使用的非常多】规则，API可以把请求url解析映射到匹配该命名空间规则的服务接口。 在Micro体系中，服务都会有自己的命名空间，而API的默认命名空间是go.micro.api。通常，部署在其后提供具体接口的微服务，我们会默认按照Micro风格将它们的命名空间设置为go.micro.api.example的样式，example便是具体的服务名，如果需要改动这个值，在启动时指定--namespace=指定名称指令即可。 运行12345678# 默认的端口是8080micro api# 2020-02-04 19:04:20 [api] Registering API Default Handler at /# 2020-02-04 19:04:20 [api] HTTP API Listening on [::]:8080# 2020-02-04 19:04:20 [api] Starting [service] go.micro.api# 2020-02-04 19:04:20 [api] Server [grpc] Listening on [::]:37275# 2020-02-04 19:04:20 [api] Registry [mdns] Registering node: go.micro.api-bdbf0099-282a-4b65-bb02-5ad48573c910 另外，API也使用了go-api，这样，它的接口handler处理器也是可以配置的。 HandlersHandler负责持有并管理HTTP请求路由。 默认的handler使用从注册中心获取的端口元数据来决定指向服务的路由，如果路由不匹配，就会回退到使用”rpc” hander。 API有如下方法可以配置请求handler： - 类型 说明 1 rpc 通过RPC向go-micro应用转送请求，只接收GET和POST请求，GET转发RawQuery，POST转发Body 2 api 与rpc差不多，但是会把完整的http头封装向下传送，不限制请求方法 3 http或proxy 以反向代理的方式使用API，相当于把普通的web应用部署在API之后，让外界像调api接口一样调用web服务 4 web 与http差不多，但是支持websocket 5 event 代理event事件服务类型的请求 6 meta* 默认值，元数据，通过在代码中的Endpoint配置选择使用上述中的某一个处理器，默认RPC 重点讲一下rpc和api两种类型的区别，它们的区别就在于，rpc不会把请求头信息封装传下去，而api会。 meta，并无此模式，只是对api、rpc、proxy、web等模式的扩展使用方法。 Endpoint在路由中会优先匹配，所以使用rpc或api模式同样可以使用此方法定义灵活的路由。 版本（V1）无法支持多个handler并存运行 请求映射RPC/API类型Micro内部有将http请求路径映射到服务的机制，映射规则可以通过下表介绍 http路径 后台服务 接口方法 /foo/bar go.micro.api.foo Foo.Bar /foo/bar/baz go.micro.api.foo Bar.Baz /foo/bar/baz/cat go.micro.api.foo.bar Baz.Cat 默认的命名空间是go.micro.api，上面说过可以通过--namespace指令自定义。 而有些带版本号的路径，也可以映射到服务名上 请求路径 后台服务 接口方法 /foo/bar go.micro.api.foo Foo.Bar /v1/foo/bar go.micro.api.v1.foo Foo.Bar /v1/foo/bar/baz go.micro.api.v1.foo Bar.Baz /v2/foo/bar go.micro.api.v2.foo Foo.Bar /v2/foo/bar/baz go.micro.api.v2.foo Bar.Baz 从上面的映射规则中可以看出，RPC/API模式下，路径后面的两个参数会被组合成Golang公共方法路径名，而剩下的会加上命名空间前缀组成服务名。比如： /v1/foo/bar/baz，其中bar/baz首字母大写转成Bar.Baz方法路径；剩下的/v1/foo/，附加上命名空间前缀go.micro.api组成go.micro.api.v1.foo。 Proxy类型如果我们启动API时传指令--handler=http，那么API便会反向代理请求到具有API命名空间的后台服务中。 比如： 请求路径 服务 后台服务路径 /greeter go.micro.api.greeter /greeter /greeter/:name go.micro.api.greeter /greeter/:name Event类型启动API时传指令--handler=event，那么API便会反向代理请求到具有API命名空间的后台事件消费服务中。 比如（命名空间设置为go.micro.evt）： 请求路径 服务 方法 /user/login go.micro.evt.user 侦听器对象（示例中的new(Event)）所有公共方法，且方法要有ctx和事件参数 如果看到这里，觉得有点绕。别着急接着看，接下来我们将自己实现这些 handler。","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Go-Micro学习笔记 - 3. 编写服务","slug":"go-micro-book3","date":"2020-02-03T16:00:00.000Z","updated":"2020-03-18T02:10:25.488Z","comments":true,"path":"2020/02/04/go-micro-book3/","link":"","permalink":"https://wolferhua.github.io/2020/02/04/go-micro-book3/","excerpt":"","text":"编写服务 顶级的服务接口Service，是构建服务所需的主要组件。它把所有Go-Micror的基础包打包成单一组件接口。 12345678type Service interface &#123; Init(...Option) Options() Options Client() client.Client Server() server.Server Run() error String() string&#125; 一、初始化服务创建目录12# 我的目录结构大概是这样的。之后的操作我们都是基于 `$GOPATH/src/gitee.com/wolferhua/go-micro-demo/demo001` 目录里边的相对路径。后边就不赘述了。mkdir -p $GOPATH/src/gitee.com/wolferhua/go-micro-demo/demo001/srv1 初始化服务创建文件 srv1/main.go 写入以下代码。 123456789101112package mainimport ( \"fmt\" micro \"github.com/micro/go-micro/v2\")func main() &#123; // 创建服务 service := micro.NewService( micro.Name(\"com.anycps.wolferhua.srv1\"), micro.Version(\"latest\"), )&#125; 初始化go module12345678# 初始化go mod init# 下载依赖go mod tidy############ 异常以后多试几次，直到成功为止，由于之前已经配置了`goproxy`代理，一般情况都能下载成功。如果多次还是不行：那么，你出墙吧。########### 二、定义APIgo micro 推荐使用 protobuf 来定义服务的API接口。使用protobuf可以非常方便去严格定义API，提供服务端与客户端双边具体一致的类型。 srv1/proto/srv1/srv1.proto 12345678910111213syntax = &quot;proto3&quot;;service Srv1 &#123; rpc Hello(HelloRequest) returns (HelloResponse) &#123;&#125;&#125;message HelloRequest &#123; string name = 1;&#125;message HelloResponse &#123; string greeting = 2;&#125; 三、生成API12cd srv1/proto/srv1protoc --proto_path=$GOPATH/src:. --micro_out=. --go_out=. srv1.proto 生成的类现在可以引入handler中，在服务或客户端来创建请求了。 12345# 生成后文件结构如下# └── srv1# ├── srv1.pb.go# ├── srv1.pb.micro.go# └── srv1.proto 四、实现handler处理器服务端需要注册handlers，这样才能提供服务并接收请求。处理器相当于是一个拥有公共方法的公共类，它需要符合签名func(ctx context.Context, req interface{}, rsp interface{}) error 通过上面文件的内容，我们看到，Srv1 interface的签名的看上去就是这样： 123type Srv1Service interface &#123; Hello(ctx context.Context, in *HelloRequest, opts ...client.CallOption) (*HelloResponse, error)&#125; Srv1处理器实现：srv1/handler/srv1.go 12345678910111213141516package handlerimport ( context \"context\" \"os\" \"strconv\" srv1 \"gitee.com/wolferhua/go-micro-demo/demo001/srv1/proto/srv1\" )type Srv1 struct&#123;&#125;func (g *Srv1) Hello(ctx context.Context, req *srv1.HelloRequest, rsp *srv1.HelloResponse) error &#123; // 业务逻辑处理代码…… rsp.Greeting = \"Hello \" + req.Name + \" ,from pid \" + strconv.Itoa(os.Getpid()) return nil&#125; 注册处理器srv1/main.go 12345678import ( // 引入proto定义 srv1 \"gitee.com/wolferhua/go-micro-demo/demo001/srv1/proto/srv1\" // 注册处理器srv1.RegisterSrv1Handler(service.Server(),new(handler.Srv1)) 五、运行服务123if err := service.Run(); err != nil &#123; log.Fatal(err)&#125; 六、完整代码srv1/main.go 123456789101112131415161718192021222324252627package mainimport ( \"gitee.com/wolferhua/go-micro-demo/demo001/srv1/handler\" micro \"github.com/micro/go-micro/v2\" \"github.com/micro/go-micro/v2/util/log\" // 引入proto定义 srv1 \"gitee.com/wolferhua/go-micro-demo/demo001/srv1/proto/srv1\")func main() &#123; // 创建服务 service := micro.NewService( micro.Name(\"com.anycps.wolferhua.srv1\"), micro.Version(\"latest\"), ) // 注册处理器 srv1.RegisterSrv1Handler(service.Server(), new(handler.Srv1)) if err := service.Run(); err != nil &#123; log.Fatal(err) &#125;&#125; srv1/handler/srv1.go 12345678910111213141516package handlerimport ( context \"context\" \"os\" \"strconv\" srv1 \"gitee.com/wolferhua/go-micro-demo/demo001/srv1/proto/srv1\" )type Srv1 struct&#123;&#125;func (g *Srv1) Hello(ctx context.Context, req *srv1.HelloRequest, rsp *srv1.HelloResponse) error &#123; // 业务逻辑处理代码…… rsp.Greeting = \"Hello \" + req.Name + \" ,from pid \" + strconv.Itoa(os.Getpid()) return nil&#125; 七、启动服务1234567891011121314cd srv1 go run main.go# 2020-02-04 16:33:40 Starting [service] srv1# 2020-02-04 16:33:40 Server [grpc] Listening on [::]:42045# 2020-02-04 16:33:40 Registry [mdns] Registering node: srv1-316a090a-5778-458c-98fa-46949a94c1db## 查看服务列表micro list services# com.anycps.wolferhua.srv1 # 这个就是我们编写的服务 编写客户端一、定义API 参考服务的定义API 二、生成API 参考服务的生成API 客户端调用服务时需要和服务端的API定义一致，所以 定义、生成 是一样的，这里就不重复讲了，直接开始吧。 三、编写代码client1/main.go 123456789101112131415161718192021222324252627282930313233package mainimport ( \"context\" \"fmt\" \"github.com/micro/go-micro/v2/util/log\" \"gitee.com/wolferhua/go-micro-demo/demo001/client1/proto/srv1\" micro \"github.com/micro/go-micro/v2\")func main() &#123; // 创建服务 service := micro.NewService() // 获取客户端对象 client := service.Client() // 创建srv1 客户端 srv1Client := srv1.NewSrv1Service(\"com.anycps.wolferhua.srv1\", client) // 在Srv1 handler上请求调用Hello方法 rsp, err := srv1Client.Hello(context.TODO(), &amp;srv1.HelloRequest&#123; Name: \"Srv1\", &#125;) if err != nil &#123; log.Fatal(err) return &#125; fmt.Println(\"服务端返回的内容为：\", rsp.Greeting)&#125; 初始化go module12345678# 初始化go mod init# 下载依赖go mod tidy############ 异常以后多试几次，直到成功为止，由于之前已经配置了`goproxy`代理，一般情况都能下载成功。如果多次还是不行：那么，你出墙吧。########### 四、运行客户端123456789101112131415cd client1go run main.go # 服务端返回的内容为： Hello Srv1 ,from pid 10086# 如果启动多个服务程序，那么多次执行会返回不同结果。可能产生如下输出。# 服务端返回的内容为： Hello Srv1 ,from pid 10086# 服务端返回的内容为： Hello Srv1 ,from pid 10087# 服务端返回的内容为： Hello Srv1 ,from pid 10086# 服务端返回的内容为： Hello Srv1 ,from pid 10086# 服务端返回的内容为： Hello Srv1 ,from pid 10086# 服务端返回的内容为： Hello Srv1 ,from pid 10087# 这是由于`micro`实现了负载均衡。 代码仓库 Srv1代码 Client代码","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Go-Micro学习笔记 - 2. micro 依赖、工具 安装","slug":"go-micro-book2","date":"2020-02-03T07:41:24.000Z","updated":"2020-03-17T14:41:45.211Z","comments":true,"path":"2020/02/03/go-micro-book2/","link":"","permalink":"https://wolferhua.github.io/2020/02/03/go-micro-book2/","excerpt":"","text":"本笔记基于go-micro/v2所以笔记中会多次出现v2引用，如果使用发现问题，请排查你的go-micro，micro，protoc-gen-micro版本是否匹配。 go依赖1234567891011# 解决golang.org/x/xxx 不能下载的问题。mkdir -p $GOPATH/src/golang.org/xmkdir -p $GOPATH/src/google.golang.orggit clone https://github.com/golang/text.git $GOPATH/src/golang.org/x/textgit clone https://github.com/golang/tools.git $GOPATH/src/golang.org/x/toolsgit clone https://github.com/golang/net.git $GOPATH/src/golang.org/x/netgit clone https://github.com/golang/crypto.git $GOPATH/src/golang.org/x/cryptogit clone https://github.com/golang/exp.git $GOPATH/src/golang.org/x/expgit clone https://github.com/grpc/grpc-go.git $GOPATH/src/google.golang.org/grpcgit clone https://github.com/googleapis/go-genproto.git $GOPATH/src/google.golang.org/genprotogit clone https://github.com/googleapis/google-api-go-client.git $GOPATH/src/google.golang.org/api 或者在gomod文件中写下如下指令： 这个操作只针对某个module生效，并不是全局的。 12345678910replace golang.org/x/text =&gt; github.com/golang/text latest replace golang.org/x/tools =&gt; github.com/golang/tools latest replace golang.org/x/net =&gt; github.com/golang/net latest replace golang.org/x/crypto =&gt; github.com/golang/crypto latest replace golang.org/x/exp =&gt; github.com/golang/exp latest replace cloud.google.com/go =&gt; github.com/googleapis/google-cloud-go latestreplace google.golang.org/grpc =&gt; github.com/grpc/grpc-go latest replace google.golang.org/genproto =&gt; github.com/googleapis/go-genproto latestreplace google.golang.org/api =&gt; github.com/googleapis/google-api-go-client latest go-micro1go get github.com/micro/go-micro/v2 micro 工具包安装 Micro是查询和访问微服务的工具包 http到rpc的API网关 Web微服务的Web代理 Sidecar作为服务网格 用于命令行访问的CLI Bot通过Slack进行查询 123456go get github.com/micro/micro/v2# 安装完成测试micro -v# micro version 2.0.0 Protobuf1234567891011121314151617181920212223go get github.com/micro/protobuf/&#123;proto,protoc-gen-go&#125;go get github.com/micro/protoc-gen-micro/v2## protoc 安装#### LINUX ###wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-linux-x86_64.zip -O $GOPATH/protoc.zip#### Mac OS ###wget https://github.com/protocolbuffers/protobuf/releases/download/v3.11.3/protoc-3.11.3-osx-x86_64.zip -O $GOPATH/protoc.zip## 解压unzip $GOPATH/protoc.zip -d $GOPATH/protoccp $GOPATH/protoc/bin/protoc $GOPATH/bin# 安装完成测试protoc --version# libprotoc 3.11.3 服务发现Multicast DNS 本地调试推荐使用 我们可以使用Multicast DNS进行零依赖的服务发现 将--registry=mdns或者MICRO_REGISTRY=mdns传递给任何命令，例如micro --registry = mdns list services etcd12345678910111213export DATA_DIR=$HOME/data/etcd-datamkdir -p $DATA_DIRexport NODE1=`本机ip地址`docker run \\ -p 2379:2379 \\ -p 2380:2380 \\ --volume=$&#123;DATA_DIR&#125;:/etcd-data \\ --name etcd quay.io/coreos/etcd:latest \\ /usr/local/bin/etcd \\ --data-dir=/etcd-data --name node1 \\ --initial-advertise-peer-urls http://$&#123;NODE1&#125;:2380 --listen-peer-urls http://$&#123;NODE1&#125;:2380 \\ --advertise-client-urls http://$&#123;NODE1&#125;:2379 --listen-client-urls http://$&#123;NODE1&#125;:2379 \\ --initial-cluster node1=http://$&#123;NODE1&#125;:2380 consul1docker run -p 8600:8600 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8301:8301/udp -p 8302:8302/udp consul","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"Go-Micro学习笔记 - 1. 基础环境配置","slug":"go-micro-book1","date":"2020-02-03T06:15:59.000Z","updated":"2020-03-18T02:10:41.738Z","comments":true,"path":"2020/02/03/go-micro-book1/","link":"","permalink":"https://wolferhua.github.io/2020/02/03/go-micro-book1/","excerpt":"","text":"基础环境配置 由于项目使用了低版本的golang，如果直接升级golang会存在老项目异常问题，所以需要在机器上配置另外一套go环境。此环境配置方法适用于linux、MacOs 。windows 可以参考配置。 基本目录创建12345# GROOTmkdir -p $HOME/workspace/go13/go# GOPATHmkdir -p $HOME/workspace/go13 安装包下载 由于网络环境原因，推荐使用国内下载镜像：http://mirrors.ustc.edu.cn/golang/ 系统包 Linux： go1.13.7.linux-amd64.tar.gz 1wget http://mirrors.ustc.edu.cn/golang/go1.13.7.linux-amd64.tar.gz -O $GOPATH/go1.13.7.tar.gz MacOs： go1.13.7.darwin-amd64.tar.gz 1wget http://mirrors.ustc.edu.cn/golang/go1.13.7.darwin-amd64.tar.gz -O $GOPATH/go1.13.7.tar.gz 解压12tar -zxvf $GOPATH/go1.13.7.tar.gz -C $HOME/workspace/go13mv $GOPATH/go $GOPATH/go1.13.7 配置编辑器 该编辑器配置针对于GoLand 设置GOROOT 设置GOPATH 由于删除了全局Global GOPATH，所以以前的项目都需要设置一下Project GOPATH。参考着配置一下。 启用GOMOD 123# 使用阿里云的 goproxy# 在编辑器中配置即可，无需执行以下代码export GOPROXY=https://mirrors.aliyun.com/goproxy/ 验证环境 由于这个配置仅对编辑器生效，所以目前系统默认环境还是以前老环境。这个配置在编辑器外使用是无效的 系统默认终端 编辑器终端 至此go-micro的golang环境已经搭建完毕。","categories":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/categories/go/"},{"name":"micro","slug":"go/micro","permalink":"https://wolferhua.github.io/categories/go/micro/"}],"tags":[{"name":"go","slug":"go","permalink":"https://wolferhua.github.io/tags/go/"},{"name":"micro","slug":"micro","permalink":"https://wolferhua.github.io/tags/micro/"},{"name":"microservice","slug":"microservice","permalink":"https://wolferhua.github.io/tags/microservice/"}]},{"title":"kubernetes(k8s)安装记录-ubuntu18.04单master","slug":"k8s-install","date":"2020-01-02T08:17:12.000Z","updated":"2020-03-04T06:01:28.955Z","comments":true,"path":"2020/01/02/k8s-install/","link":"","permalink":"https://wolferhua.github.io/2020/01/02/k8s-install/","excerpt":"","text":"安装基于ubuntu 18.04，镜像源为: https://developer.aliyun.com/mirror/ubuntu 配置要求 节点 配置（最低要求） IP 主机名称 master 2C2G 192.168.2.30 ubuntu-vm-30 worker1 1C1G 192.168.2.31 ubuntu-vm-31 worker2 1C1G 192.168.2.32 ubuntu-vm-32 关闭防火墙1sudo ufw disable 关闭系统swap12# 修改/etc/fstab 注释掉swap项目sudo swapoff -a 安装docker123456789101112# step 1: 安装必要的一些系统工具sudo apt updatesudo apt -y install apt-transport-https ca-certificates curl software-properties-common# step 2: 安装GPG证书curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# Step 3: 写入软件源信息sudo add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"# Step 4: 更新并安装Docker-CEsudo apt -y updatesudo apt -y install docker-ce# Step 5: 将当前用户加入用户组sudo usermod -a -G docker $USER 修改docker 配置 https://kubernetes.io/docs/setup/production-environment/container-runtimes/ 12345678910111213141516171819# 切换账号 sudo su# 写入配置cat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123; \"exec-opts\": [\"native.cgroupdriver=systemd\"], \"log-driver\": \"json-file\", \"log-opts\": &#123; \"max-size\": \"100m\" &#125;, \"storage-driver\": \"overlay2\"&#125;EOFmkdir -p /etc/systemd/system/docker.service.d# 重启 docker.systemctl daemon-reloadsystemctl restart docker 下载安装k8s 配置apt源。 1234567891011# 更新&amp;&amp;安装必要的一些系统工具apt update &amp;&amp; apt install -y apt-transport-https# 安装GPG证书curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - # 配置k8s源cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.listdeb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial mainEOF# 配置以后更新apt updateapt install -y kubelet kubeadm kubectl 所有机器都必须安装 docker、kubelet、kubeadm、kubectl 初始化（仅运行于master）12345678910111213141516171819202122232425262728sudo kubeadm init --apiserver-advertise-address 192.168.2.30 --pod-network-cidr=10.244.0.0/16# init 常用主要参数：# –kubernetes-version: 指定Kubenetes版本，如果不指定该参数，会从google网站下载最新的版本信息。 v1.17.0# –pod-network-cidr: 指定pod网络的IP地址范围，它的值取决于你在下一步选择的哪个网络网络插件，比如我在本文中使用的是 calico 网络，需要指定为10.244.0.0/16。# –apiserver-advertise-address: 指定master服务发布的Ip地址，如果不指定，则会自动检测网络接口，通常是内网IP。# --image-repository： 指定docker镜像拉取。sudo kubeadm init --image-repository registry.aliyuncs.com/google_containers --apiserver-advertise-address 192.168.2.30 --kubernetes-version v1.17.0 --pod-network-cidr=10.240.0.0/16# Your Kubernetes control-plane has initialized successfully!# To start using your cluster, you need to run the following as a regular user:# mkdir -p $HOME/.kube# sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config# sudo chown $(id -u):$(id -g) $HOME/.kube/config# You should now deploy a pod network to the cluster.# Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at:# https://kubernetes.io/docs/concepts/cluster-administration/addons/# Then you can join any number of worker nodes by running the following on each as root:# kubeadm join 192.168.2.30:6443 --token vgnn2t.kmq1gqchcwobv7lj \\# --discovery-token-ca-cert-hash sha256:66d4cba6bad6daba940a87ee29a190386584d8bdeb77145b906914a8c2dd9a64 配置kubectl123mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config 安装 calico Calico是一个纯三层的方案，为虚机及容器提供多主机间通信，没有使用重叠网络（如flannel）驱动，采用虚拟路由代替虚拟交换，每一台虚拟路由器通过BGP协议传播可达信息（路由）到其他虚拟或物理路由器。 https://www.cnblogs.com/netonline/p/9720279.html 1234567# 参考文档 https://docs.projectcalico.org/v3.10/getting-started/kubernetes/cd $HOME/.kubewget https://kuboard.cn/install-script/calico/calico-3.10.2.yamlsed -i \"s#192\\.168\\.0\\.0/16#10\\.244\\.0\\.0/16#\" calico-3.10.2.yamlkubectl apply -f calico-3.10.2.yaml 检查初始化结果12345678# 只在 master 节点执行# 执行如下命令，等待 3-10 分钟，直到所有的容器组处于 Running 状态watch kubectl get pod -n kube-system -o wide# 查看 master 节点初始化结果kubectl get nodes -o wide# NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME#loyo-vm Ready master 15m v1.17.0 192.168.2.30 &lt;none&gt; Ubuntu 18.04.3 LTS 4.15.0-72-generic docker://19.3.5 初始化Worker获得加入命令12345678910111213141516171819202122232425262728# 在master节点执行kubeadm token create --print-join-command# 有效时间两小时# W1231 07:24:53.712544 7649 validation.go:28] Cannot validate kube-proxy config - no validator is available# W1231 07:24:53.713100 7649 validation.go:28] Cannot validate kubelet config - no validator is available# kubeadm join 192.168.2.30:6443 --token 0zcj6i.ibrv1n0914oamhvf --discovery-token-ca-cert-hash sha256:66d4cba6bad6daba940a87ee29a190386584d8bdeb77145b906914a8c2dd9a64## 执行加入sudo kubeadm join 192.168.2.30:6443 --token 0zcj6i.ibrv1n0914oamhvf --discovery-token-ca-cert-hash sha256:66d4cba6bad6daba940a87ee29a190386584d8bdeb77145b906914a8c2dd9a64# W1231 07:25:29.249270 2005 join.go:346] [preflight] WARNING: JoinControlPane.controlPlane settings will be ignored when control-plane flag is not set.# [preflight] Running pre-flight checks# [preflight] Reading configuration from the cluster...# [preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -oyaml'# [kubelet-start] Downloading configuration for the kubelet from the \"kubelet-config-1.17\" ConfigMap in the kube-system namespace# [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\"# [kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\"# [kubelet-start] Starting the kubelet# [kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...# This node has joined the cluster:# * Certificate signing request was sent to apiserver and a response was received.# * The Kubelet was informed of the new secure connection details.# Run 'kubectl get nodes' on the control-plane to see this node join the cluster. 安装 Ingress Controlleringress介绍 1234# master 上执行# 如果打算用于生产环境，请参考 https://github.com/nginxinc/kubernetes-ingress/blob/v1.5.5/docs/installation.md 并根据您自己的情况做进一步定制kubectl apply -f https://kuboard.cn/install-script/v1.17.x/nginx-ingress.yaml 安装教程参考 使用kubeadm安装kubernetes_v1.17.x k8s ubuntu18 安装 Kubernetes CNI网络最强对比：Flannel、Calico、Canal和Weave","categories":[{"name":"kubernetes","slug":"kubernetes","permalink":"https://wolferhua.github.io/categories/kubernetes/"}],"tags":[]},{"title":"Linux安装","slug":"linux-002-install","date":"2019-10-26T06:02:24.000Z","updated":"2020-02-10T11:07:12.018Z","comments":true,"path":"2019/10/26/linux-002-install/","link":"","permalink":"https://wolferhua.github.io/2019/10/26/linux-002-install/","excerpt":"","text":"资源准备 VMware Workstation Pro Ubuntu VMware Workstation Pro 开放密钥 GV7N2-DQZ00-4897Y-27ZNX-NV0TD 创建虚拟机 新建虚拟机 选择自定义 虚拟机兼容版本设置，默认选择当前Vmware版本 选择”稍后选择操作系统“ vmeare做虚拟机时间非常久了，Ubuntu这种系统被安装过无数次，所以如果你选择了安装程序光盘，他可能会执行快速安装模式。会缺少自定义过程。 选择虚拟机系统类型 自定义虚拟机名称 设置CPU和内存：2核2G 设置网络 磁盘设置 最后选择单个磁盘，这样虚拟机性能能达到最高。 虚拟磁盘文件名称 选择安装镜像 系统安装 语言 Install Ubuntu Server 设置语言和键盘 设置主机名称 用户名和密码设置 设置时区：Asia/Shanghai、Asia/Chongqing 磁盘分区 直接选择LVM分区就好，目前分区条件已经成熟，无需像老版本那样自己去分割磁盘。现有的选项就是最常用的分区逻辑了。 代理设置，没有不用设置：可能会稍微等一会 系统更新到最新版本 由于我们安装的是Server版本，最好选择安装ssh 写入引导 登录系统 安装完成","categories":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"}]},{"title":"Linux简介","slug":"linux-001-intro","date":"2019-10-26T06:02:19.000Z","updated":"2020-02-10T11:07:12.017Z","comments":true,"path":"2019/10/26/linux-001-intro/","link":"","permalink":"https://wolferhua.github.io/2019/10/26/linux-001-intro/","excerpt":"","text":"Linux is not Unix。 Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。 当年 linus 就是因为接触到了unix而后才自己想开发一个简易的系统内核的，他开发的简易系统内核其实就是linux。当时linus 把开发的这个系统内核丢到网上提供大家下载，由于它的精致小巧，越来越多的爱好者去研究它。人们对这个内核添枝加叶，而后成为了一个系统。也许你听说过吧，linux 是免费的。其实这里的免费只是说linux的内核免费。在 linux 内核的基础上而产生了众多 linux 的版本。 发行版关系- 均是使用linux内核，提供硬件、磁盘、文件系统、多任务的核心操作。 - 不同发行版定位不一样：面向个人桌面或企业服务。区别- 内核版本不同 - 包管理器不同 `最大的区别`Linux 思想1、 一切接皆文件几乎把所有的资源系统抽象为文件形式：包括硬件设备，甚至通信接口等。作用：提高资源管理效率。例如： 物理终端：/dev/console 虚拟终端：/dev/tty#（#为1~6） 串行终端：/dev/ttyS# 伪终端：/dev/pts/# /dev/zero 一个可以都出无限个0的文件 /dev/null 一个重定向进去之后就消失了的文件，相当于黑洞 …… 优点：可以使用同一套机制来处理Linux系统中的大多数资源。比如系统调用：open(), read(), write(), close(), delete(), create() 2、 由众多功能单一的程序共同完成复杂任务Linux倾向于让一个程序只做一件事，并且做好；让这样的程序能够基于统一的标准开放接口，再由多个这种功能单一的程序组合起来，共同完成更为复杂的任务。 优点：程序代码更轻量，更高效；出现错误更容易定位；程序的功能延展更具灵活性； 3、 尽量避免跟用户交互正是由于面向的对象不同，Linux系统管理多使用命令行接口，通过命令对系统进行操作和管理，这与Windows的设计理念有着迥然的区别。 优点：易于以编程的方式实现自动化任务；为自动化运维，乃至DevOps日后的发展奠定了基础。 4、 使用文本文件保存配置信息所有的配置文件都采用文本文件的方式保存，管理人员可以通过vi或vim文本编辑工具对其进行修改。 优点：方便管理者对应用软件进行配置、检查工作，而且为避免服务因修改配置中断，多数应用程序也会针对配置文件的更改提供不中断服务的reload操作，这也是Linux系统运行比Windows稳定的一个因素。 5、 提供机制，而非策略 机制，是实现某个功能需要的原语操作和结构 策略，是某功能的具体实现 优点： 提供机制，而非策略，指的就是要给用户充分的自主可调配性","categories":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"}]},{"title":"Docker入门教程（十一）Docker Swarm","slug":"docker-011","date":"2019-09-08T03:33:31.000Z","updated":"2020-02-10T11:07:12.017Z","comments":true,"path":"2019/09/08/docker-011/","link":"","permalink":"https://wolferhua.github.io/2019/09/08/docker-011/","excerpt":"","text":"0. Docker SwarmSwarm 是 Docker 社区提供的唯一一个原生支持 Docker 集群管理的工具。它可以把多个 Docker 主机组成的系统转换为单一的虚拟 Docker 主机，使得容器可以组成跨主机的子网网络。Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令。 测试123456789101112131415161718docker swarm --help# Usage: docker swarm COMMAND# Manage Swarm# Commands:# ca Display and rotate the root CA# init Initialize a swarm# join Join a swarm as a node and/or manager# join-token Manage join tokens# leave Leave the swarm# unlock Unlock swarm# unlock-key Manage the unlock key# update Update the swarm# Run 'docker swarm COMMAND --help' for more information on a command. 1. 环境准备版本检查12345678910111213141516171819docker version# Client:# Version: 18.09.6-ce# API version: 1.39# Go version: go1.12.4# Git commit: 481bc77156# Built: Sat May 11 06:11:03 2019# OS/Arch: linux/amd64# Experimental: false# Server:# Engine:# Version: 18.09.6-ce# API version: 1.39 (minimum version 1.12)# Go version: go1.12.4# Git commit: 481bc77156# Built: Sat May 11 06:10:35 2019# OS/Arch: linux/amd64# Experimental: false 机器列表 测试时可以使用Docker Machine（Docker三剑客之一）便捷的创建虚拟机，本教程不涉及相关知识。大家可以自己去学习一下。 Manager 192.168.65.95 — manjaro Worker1 192.168.65.21 — alpine Worker2 192.168.65.22 — alpine 2. 创建manager1234567891011121314# 使用默认网卡ip地址docker swarm init # 当存在多个ip地址时需要指定ip地址docker swarm init --advertise-addr 192.168.65.95# Swarm initialized: current node (m1z4ppjigoqyr625bqju05ygb) is now a manager.# To add a worker to this swarm, run the following command:## 使用下边的命令添加 worker# docker swarm join --token SWMTKN-1-51v6cmdfaz1miits0npifyif2i4dcubvtoejc660pmj5c9ud0z-9wuwp1rgyss4pffsyo9qgyx0h 192.168.65.95:2377## 如果需要添加 manager 使用 docker swarm join-token manager 获取加入命令。# To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.## 如果需要添加 manager 使用 docker swarm join-token worker 获取加入命令。 3. 将worker加入集群 分别登录worker节点，执行下边命令。 12345docker swarm join --token SWMTKN-1-51v6cmdfaz1miits0npifyif2i4dcubvtoejc660pmj5c9ud0z-9wuwp1rgyss4pffsyo9qgyx0h 192.168.65.95:2377## This node joined a swarm as a worker.# 4. 查看节点状态12345docker node ls# ID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION# hoyv9djysw7cq67oc44bksz00 alpine-21 Ready Active 18.09.1-ce# wfthauhq7yem8d34hm9xxoaqe alpine-22 Ready Active 18.09.1-ce# m1z4ppjigoqyr625bqju05ygb * manjaro Ready Active Leader 18.09.6-ce 5. 基本使用5.0 基础命令12345678910111213141516 docker service --help # Usage: docker service COMMAND# Manage services# Commands:# create Create a new service# inspect Display detailed information on one or more services# logs Fetch the logs of a service or task# ls List services# ps List the tasks of one or more services# rm Remove one or more services# rollback Revert changes to a service's configuration# scale Scale one or multiple replicated services# update Update a service 5.1 创建服务1234567docker service create --replicas 1 --name myservice daocloud.io/alpine ping 127.0.0.1# mvzgvw3we89sfhm4tea8i24l6# overall progress: 1 out of 1 tasks # 1/1: running [==================================================&gt;] # verify: Service converged 5.2 服务列表1234docker service ls# ID NAME MODE REPLICAS IMAGE PORTS# mvzgvw3we89s myservice replicated 1/1 daocloud.io/alpine:latest 5.3 查看服务信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374docker service inspect myservice# [# &#123;# \"ID\": \"mvzgvw3we89sfhm4tea8i24l6\",# \"Version\": &#123;# \"Index\": 33# &#125;,# \"CreatedAt\": \"2019-06-17T08:31:45.64841901Z\",# \"UpdatedAt\": \"2019-06-17T08:31:45.64841901Z\",# \"Spec\": &#123;# \"Name\": \"alpine\",# \"Labels\": &#123;&#125;,# \"TaskTemplate\": &#123;# \"ContainerSpec\": &#123;# \"Image\": \"daocloud.io/alpine:latest@sha256:bf1684a6e3676389ec861c602e97f27b03f14178e5bc3f70dce198f9f160cce9\",# \"Args\": [# \"ping\",# \"127.0.0.1\"# ],# \"Init\": false,# \"StopGracePeriod\": 10000000000,# \"DNSConfig\": &#123;&#125;,# \"Isolation\": \"default\"# &#125;,# \"Resources\": &#123;# \"Limits\": &#123;&#125;,# \"Reservations\": &#123;&#125;# &#125;,# \"RestartPolicy\": &#123;# \"Condition\": \"any\",# \"Delay\": 5000000000,# \"MaxAttempts\": 0# &#125;,# \"Placement\": &#123;# \"Platforms\": [# &#123;# \"Architecture\": \"amd64\",# \"OS\": \"linux\"# &#125;# ]# &#125;,# \"ForceUpdate\": 0,# \"Runtime\": \"container\"# &#125;,# \"Mode\": &#123;# \"Replicated\": &#123;# \"Replicas\": 1# &#125;# &#125;,# \"UpdateConfig\": &#123;# \"Parallelism\": 1,# \"FailureAction\": \"pause\",# \"Monitor\": 5000000000,# \"MaxFailureRatio\": 0,# \"Order\": \"stop-first\"# &#125;,# \"RollbackConfig\": &#123;# \"Parallelism\": 1,# \"FailureAction\": \"pause\",# \"Monitor\": 5000000000,# \"MaxFailureRatio\": 0,# \"Order\": \"stop-first\"# &#125;,# \"EndpointSpec\": &#123;# \"Mode\": \"vip\"# &#125;# &#125;,# \"Endpoint\": &#123;# \"Spec\": &#123;&#125;# &#125;# &#125;# ] 5.4 扩展服务12345678910docker service scale myservice=5# myservice scaled to 5# overall progress: 5 out of 5 tasks # 1/5: running [==================================================&gt;] # 2/5: running [==================================================&gt;] # 3/5: running [==================================================&gt;] # 4/5: running [==================================================&gt;] # 5/5: running [==================================================&gt;] # verify: Service converged 5.4 查看服务状态1234567docker service ps myservice # ID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS# zm0gt7xpgfle myservice.1 daocloud.io/alpine:latest manjaro Running Running 8 minutes ago # nxm0xfp4kcrp myservice.2 daocloud.io/alpine:latest alpine-21 Running Running about a minute ago # 6g4g3wctgyz0 myservice.3 daocloud.io/alpine:latest alpine-22 Running Running about a minute ago # v9i18qk4jr6d myservice.4 daocloud.io/alpine:latest alpine-22 Running Running about a minute ago # d4462wbx1bmc myservice.5 daocloud.io/alpine:latest manjaro Running Running about a minute ago 5.5 查看服务日志1docker service logs myservice 5.5 删除服务1docker service rm myservice 结合 docker-compose.yml基础应用docker-compose.ymldocker-compose.ymlview raw12345678910111213141516version: \"3\"services: alpine: image: \"daocloud.io/alpine\" command: [\"ping\",\"127.0.0.1\"] deploy: mode: global restart: always alpine-replicated: image: \"daocloud.io/alpine\" command: [\"ping\",\"127.0.0.1\"] deploy: mode: replicated replicas: 5 restart: always 部署服务1docker stack deploy --compose-file docker-compose.yml myservic 服务列表1234## 部署列表docker stack ls## 服务列表docker service ls 服务控制123456789101112docker service scale myservice_alpine-replicated=10# myservice_alpine-replicated scaled to 10# overall progress: 10 out of 10 tasks # 1/10: running [==================================================&gt;] # ......# 10/10: running [==================================================&gt;] # verify: Service converged docker service scale myservice_alpine=10 # myservice_alpine: scale can only be used with replicated mode# 需要注意的是，如果你的服务是可以扩展的，那么服务的部署模式必须是 `replicated` 服务场景应用基础内容docker-compose.ymldocker-compose.ymlview raw123456789101112131415161718192021222324version: \"3\"services: alpine: image: \"daocloud.io/alpine\" command: [\"ping\",\"127.0.0.1\"] deploy: mode: global restart: always # nginx nginx: # 服务名称 image: \"192.168.65.95:5000/nginx:goweb\" #镜像 depends_on: - goweb ports: - \"80:80\" # 开放端口 deploy: mode: global restart: always goweb: # 服务名称 image: \"192.168.65.95:5000/goweb:goweb\" #镜像 deploy: mode: replicated replicas: 3 restart: always goweb DockerfileDockerfileview raw12345678910111213141516171819202122232425262728FROM daocloud.io/golang:alpine AS goweb-build # 添加文件到镜像COPY ./main.go /app/ # 切换目录，相当于cd xxxWORKDIR /app/RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main ./main.go# 使用基础镜像，这个镜像是一个空的镜像，没有任何内容。且不能执行任何命令FROM scratch# 作者信息MAINTAINER wolferhua &lt;wolferhua@qq.com&gt; # 切换目录，相当于cd xxxWORKDIR /app/# 添加文件到镜像COPY --from=goweb-build /app/main /app/ # 执行命令CMD [\"/app/main\"]# docker build -t 192.168.65.95:5000/goweb:goweb .# docker push 192.168.65.95:5000/goweb:goweb nginx DockerfileDockerfileview raw123456789101112131415# 指定基础镜像, 必须存在于Dockerfile 第一行FROM daocloud.io/nginx# 作者信息MAINTAINER wolferhua &lt;wolferhua@qq.com&gt;# 添加文件到镜像# 将 index.html 添加到 /usr/share/nginx/htmlADD ./index.html /usr/share/nginx/htmlADD ./www.conf /etc/nginx/conf.d/default.conf# docker build -t 192.168.65.95:5000/nginx:goweb .# docker push 192.168.65.95:5000/nginx:goweb 部署服务1docker stack deploy --compose-file docker-compose.yml goweb 完成","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"Docker入门教程（十）Docker Register","slug":"docker-010","date":"2019-08-08T06:22:48.000Z","updated":"2020-02-10T11:07:12.017Z","comments":true,"path":"2019/08/08/docker-010/","link":"","permalink":"https://wolferhua.github.io/2019/08/08/docker-010/","excerpt":"","text":"仓库第一章节的时候我们就讲过docker仓库的概念，我们提到仓库就是镜像存储的地方，有点类似于github这种平台。 为什么需要自己建立仓库？ docker的默认仓库是在国外的，所以下载效率很慢。 可以存储一些隐私数据，不被泄露。 高度可定制。 Registry 镜像Docker 官方提供了一个便捷创建仓库的能力，为此创建了一个镜像来实现自建仓库。目前版本V2.0。 运行仓库1234567docker run -d \\-p 5000:5000 \\--restart=always \\--name registry \\--env REGISTRY_STORAGE_DELETE_ENABLED=true \\-v /home/wolferhua/workspace/runtime/registry:/var/lib/registry \\daocloud.io/registry:2 参考： 仓库部署 修改配置文件1234567vim /etc/docker/daemon.json&#123; \"insecure-registries\": [ \"192.168.65.95:5000\" ]&#125; 如果不配置以上参数可能存在： 12docker pull 192.168.65.95:5000/goweb:0 # Error response from daemon: Get https://192.168.65.95:5000/v2/: http: server gave HTTP response to HTTPS client 推送镜像 为本地镜像打Tag 1docker tag goweb:0 192.168.65.95:5000/goweb:0 推送镜像 1docker push 192.168.65.95:5000/goweb:0 拉取镜像 1docker pull 192.168.65.95:5000/goweb:0 Registry API基本信息 /v2/1curl 'http://192.168.65.95:5000/v2/' -X GET 镜像列表 /v2/_catalog1curl 'http://192.168.65.95:5000/v2/_catalog' -X GET 标签列表 /v2/&lt;image&gt;/tags/list123curl 'http://192.168.65.95:5000/v2/&lt;image&gt;/tags/list' -X GET# curl 'http://192.168.65.95:5000/v2/goweb/tags/list' -X GET 获取镜像某个版本构建信息 /v2/&lt;image&gt;/manifests/&lt;referevce&gt;123curl -v 'http://192.168.65.95:5000/v2/&lt;image&gt;/manifests/&lt;referevce&gt;' -X GET# curl -v 'http://192.168.65.95:5000/v2/goweb/manifests/0' -X GET 返回头里边的： Docker-Content-Digest： xxx 就是删除时的标识。 删除镜像某个版本构建信息 /v2/&lt;image&gt;/manifests/&lt;reference&gt;123curl 'http://192.168.65.95:5000/v2/&lt;image&gt;/manifests/&lt;referevce&gt;' -X DELETE# curl 'http://192.168.65.95:5000/v2/goweb/manifests/sha256:68cf2b953f47d2569eac0855216c87944409ae4cc0648b90c8ea78e36ffea70a' -X DELETE","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"SSH私钥是OPENSSH导致程序认证异常问题","slug":"ssh-private-key-openssh","date":"2019-06-25T01:20:13.000Z","updated":"2020-02-10T11:07:12.017Z","comments":true,"path":"2019/06/25/ssh-private-key-openssh/","link":"","permalink":"https://wolferhua.github.io/2019/06/25/ssh-private-key-openssh/","excerpt":"","text":"公司项目部分使用ruby on rails构建，最近由于线上服务器权限控制问题。导致一个很老系统不能正常发布。程序异常如下 执行命令 1cap production deploy 异常返回 1234567891011121314151617181920212223242526272829303132** Invoke production (first_time)** Execute production** Invoke load:defaults (first_time)** Execute load:defaults** Invoke bundler:map_bins (first_time)** Execute bundler:map_bins** Invoke deploy:set_rails_env (first_time)** Execute deploy:set_rails_env** Invoke deploy:set_linked_dirs (first_time)** Execute deploy:set_linked_dirs** Invoke deploy:set_rails_env ** Invoke rvm:hook (first_time)** Execute rvm:hookDEBUG [287814d6] Running /usr/bin/env [ -d ~/.rvm ] as user_name@192.168.2.63DEBUG [287814d6] Command: [ -d ~/.rvm ]cap aborted!Net::SSH::AuthenticationFailed: Authentication failed for user user_name@192.168.2.63/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/net-ssh-3.0.2/lib/net/ssh.rb:242:in `start&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/connection_pool.rb:95:in `call&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/connection_pool.rb:95:in `create_new_entry&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/connection_pool.rb:38:in `checkout&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/netssh.rb:134:in `with_ssh&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/netssh.rb:87:in `execute_command&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/abstract.rb:121:in `block in create_command_and_execute&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/abstract.rb:121:in `tap&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/abstract.rb:121:in `create_command_and_execute&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/abstract.rb:34:in `test&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/capistrano-rvm-0.1.2/lib/capistrano/tasks/rvm.rake:21:in `block (3 levels) in &lt;top (required)&gt;&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/abstract.rb:15:in `instance_exec&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/backends/abstract.rb:15:in `run&apos;/home/user_name/.rvm/gems/ruby-2.2.1@loyo/gems/sshkit-1.8.1/lib/sshkit/runners/parallel.rb:13:in `block (2 levels) in execute&apos;Tasks: TOP =&gt; rvm:hook 按照网上查找的部分资料: Net::SSH::AuthenticationFailed: Authentication failed for user Net::SSH::AuthenticationFailed: Authentication failed for user root #175 并不能解决该问题，然后仔细对比线上代码。和其他程序样本对比，最后发现ssh私钥 -----BEGIN XXXXXX PRIVATE KEY----- 12/home/user_name/.ssh/id_rsa:-----BEGIN OPENSSH PRIVATE KEY-----/home/user_name/.ssh/www_id_rsa:-----BEGIN RSA PRIVATE KEY----- 然后在服务器上重新生成一个BEGIN RSA PRIVATE KEY 的私钥，测试发现通过。 1ssh-keygen -t rsa -C \"新的私钥\" -f new_id_rsa -N \"\" 不过我再次尝试用我的电脑生成一个私钥，但是生成的私钥还是BEGIN OPENSSH PRIVATE KEY。最终对比ssh版本发现版本不一致: 123456# 本地$ ssh -VOpenSSH_8.0p1, OpenSSL 1.1.1c 28 May 2019# 服务器 $ ssh ssh_ly ssh -V OpenSSH_7.2p2 Ubuntu-4ubuntu2.8, OpenSSL 1.0.2g 1 Mar 2016 查找资料发现 ssh-keygen does not create RSA private key，需要添加参数 -m PEM。 1ssh-keygen -t rsa -C \"新的私钥\" -f pem_id_rsa -N \"\" -m PEM 使用新的私钥测试通过。总算解决了。","categories":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"ssh","slug":"ssh","permalink":"https://wolferhua.github.io/tags/ssh/"}]},{"title":"Docker入门教程（九）Docker Compose","slug":"docker-009","date":"2019-05-30T05:22:27.000Z","updated":"2020-02-10T11:07:12.017Z","comments":true,"path":"2019/05/30/docker-009/","link":"","permalink":"https://wolferhua.github.io/2019/05/30/docker-009/","excerpt":"","text":"0、 什么是 Docker ComposeDocker Compose是一个使用python写的批量操作docker的一个自动化工具。 为什么要用？通过之前的学习，我们使用的镜像越来越多。每个镜像都有如下操作： RUN 挂载磁盘 开放端口 获取或者构建镜像 …… 如果只有一个还好，当我们的镜像使用的越来越多。那么操作就会越来越复杂……，如此Docker Compose应运而生，我们一起来学习一下。 1、 安装由于Docker Compose是基于python开发的，所以必须保证机器上有python环境。 Python 环境检查123456python --version# Python 3.7.3pip --version# pip 19.0.3 from /usr/lib/python3.7/site-packages/pip (python 3.7) 执行安装12345$ sudo pip install docker-compose# Collecting docker-compose# Downloading ......# Successfully installed ...... docker-compose-1.24.0 测试安装12345docker-compose version# docker-compose version 1.24.0, build 0aa5906# docker-py version: 3.7.2# CPython version: 3.7.3# OpenSSL version: OpenSSL 1.1.1b 26 Feb 2019 2. 常用命令1234567891011121314151617181920build # 构建或者重新构建服务镜像 config # 验证配置文件create # 创建服务down # 停止并删除容器、网络、镜像 exec # 在运行容器中执行命令 images # 显示使用的镜像kill # kill 运行容器logs # 显示容器日志pause # 按暂停容器 ps # 显示容器pull # 拉去使用的镜像push # 推送镜像restart # 重启服务rm # 删除停止容器run # 运行容器scale # 设置服务容器数start # 启动容器stop # 停止容器top # 显示正在运行程序up # 创建并启动容器 3. docker-compose.ymldocker-compose 是一个批量操作的工具，我们需要将我们的操作写在 docker-compose.yml 。这样docker-compose就可以根据文件里边的定义，执行操作。 内容解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778version # 指定 compose 文件的版本############## service 定义 ##############services # 定义所有的 service 信息, services 下面的第一级别的 key 是一个 service 的名称 build # 自动构建定 context # dockerfile 文件目录 dockerfile # dockerfile 文件名称 command # 容器启动后执行命令，会覆盖镜像默认CMD。支持 shell 格式和 [] 格式 entrypoint # 容器启动后执行命令，会覆盖镜像默认entrypoint。支持 shell 格式和 [] 格式 image # 指定镜像 environment # 设置环境变量参数 container_name # 指定容器的名称 (等同于 docker run --name 的作用) expose # 暴露端口, 但是不能和宿主机建立映射关系, 类似于 Dockerfile 的 EXPOSE 指令 ports # 建立宿主机和容器之间的端口映射关系, ports 支持两种语法格式 # SHORT 语法格式示例: # - \"3000\" # 暴露容器的 3000 端口, 宿主机的端口由 docker 随机映射一个没有被占用的端口 # - \"3000-3005\" # 暴露容器的 3000 到 3005 端口, 宿主机的端口由 docker 随机映射没有被占用的端口 # - \"8000:8000\" # 容器的 8000 端口和宿主机的 8000 端口建立映射关系 # - \"9090-9091:8080-8081\" # - \"127.0.0.1:8001:8001\" # 指定映射宿主机的指定地址的 # - \"127.0.0.1:5000-5010:5000-5010\" # - \"6060:6060/udp\" # 指定协议 volumes # 数据卷挂载 # volumes: # - /var/lib/mysql # 映射容器内的 /var/lib/mysql 到宿主机的一个随机目录中 # - /opt/data:/var/lib/mysql # 映射容器内的 /var/lib/mysql 到宿主机的 /opt/data # - ./cache:/tmp/cache # 映射容器内的 /var/lib/mysql 到宿主机 compose 文件所在的位置 # - ~/configs:/etc/configs/:ro # 映射容器宿主机的目录到容器中去, 权限只读 # - datavolume:/var/lib/mysql # datavolume 为 volumes 顶级键定义的目录, 在此处直接调用 deploy # v3 版本以上, 指定与部署和运行服务相关的配置, deploy 部分是 docker stack 使用的, docker stack 依赖 docker swarm resources # 资源限制 limits # 设置容器的资源限制 cpus # 设置该容器最多只能使用 50% 的 CPU : \"0.5\" memory # 设置该容器最多只能使用 50M 的内存空间 : 50M reservations # 设置为容器预留的系统资源(随时可用) cpus # 为该容器保留 20% 的 CPU : \"0.2\" memory # 为该容器保留 20M 的内存空间: 20M mode # 指定 deploy 的模式 global # 每个集群节点都只有一个容器 replicated # 用户可以指定集群中容器的数量(默认) replicas # deploy 的 mode 为 replicated 时, 指定容器副本的数量 depends_on # 定义容器启动顺序 (此选项解决了容器之间的依赖关系， 此选项在 v3 版本中 使用 swarm 部署时将忽略该选项) # version: '3' # services: # web: # build: . # depends_on: # - db # - redis # redis: # image: redis # db: # image: postgres restart # 重启策略 # no # 禁止自动重启容器(默认) # always # 无论如何容器都会重启 # on-failure # 当出现 on-failure 报错时, 容器重新启动 networks # 将容器加入指定网络 (等同于 docker network connect 的作用), networks 可以位于 compose 文件顶级键和 services 键的二级键 aliases # 同一网络上的容器可以使用服务名称或别名连接到其中一个服务的容器 ipv4_address # IP V4 格式 ipv6_address # IP V6 格式 extra_hosts # 添加 host 记录到容器中的 /etc/hosts 中 (等同于 docker run --add-host 的作用)############## network 定义 ##############networks # 定义 networks 信息 driver # 指定网络模式, 大多数情况下, 它 bridge 于单个主机和 overlay Swarm 上 bridge # Docker 默认使用 bridge 连接单个主机上的网络 overlay # overlay 驱动程序创建一个跨多个节点命名的网络 host # 共享主机网络名称空间(等同于 docker run --net=host) none # 等同于 docker run --net=none attachable # driver 为 overlay 时使用, 如果设置为 true 则除了服务之外，独立容器也可以附加到该网络; 如果独立容器连接到该网络，则它可以与其他 Docker 守护进程连接到的该网络的服务和独立容器进行通信 ipam # 自定义 IPAM 配置. 这是一个具有多个属性的对象, 每个属性都是可选的 driver # IPAM 驱动程序, bridge 或者 default config # 配置项 subnet # CIDR格式的子网，表示该网络的网段 external # 外部网络, 如果设置为 true 则 docker-compose up 不会尝试创建它, 如果它不存在则引发错误 name # v3.5 以上版本, 为此网络设置名称 案例 基础介绍以后我们先来，将之前用的镜像。通过docker-compose 来管理。 1. 准备镜像Nginx配置文件www.confview raw123456789101112131415server { listen 80; location / { root /usr/share/nginx/html; index index.html index.htm; }} server{ listen 80; server_name www-wh.anycps.com; location / { proxy_pass http://goweb:8080; proxy_redirect off; }} DockerfileDockerfileview raw123456789101112# 指定基础镜像, 必须存在于Dockerfile 第一行FROM daocloud.io/nginx# 作者信息MAINTAINER wolferhua &lt;wolferhua@qq.com&gt;# 添加文件到镜像# 将 index.html 添加到 /usr/share/nginx/htmlADD ./index.html /usr/share/nginx/htmlADD ./www.conf /etc/nginx/conf.d/ Go WebGo Codemain.goview raw12345678910111213141516171819202122package mainimport ( \"os\" \"log\" \"net/http\")type helloHandler struct{}var host = \"\"func (h *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"text/html; charset=UTF-8\" ) w.Header().Set(\"Content-Transfer-Encoding\", \"quoted-printable\") w.Write([]byte(\"Host：\"+host+\"&lt;br&gt; Hello, world! from golang.\")) //输出内容}func main() { host, _ = os.Hostname() //获取当前机器名称 http.Handle(\"/\", &amp;helloHandler{}) log.Println(\"Start web service: http://127.0.0.1:8080\") log.Fatal(http.ListenAndServe(\":8080\", nil)) //指定端口} DockerfileDockerfileview raw1234567891011121314151617181920212223242526272829303132# 指定基础镜像, 必须存在于Dockerfile 第一行FROM daocloud.io/golang# 作者信息MAINTAINER wolferhua &lt;wolferhua@qq.com&gt; # 添加文件到镜像ADD . /usr/src/app# 切换目录，相当于cd xxxWORKDIR /usr/src/app# 执行编译gRUN go build -o app main.go # 切换目录WORKDIR /app# 将编译后的移动到 /app 目录RUN mv /usr/src/app/app .# 开放端口，在运行时，并不会正在的开放端口。还是需要-p# 这里只是标明需要使用的端口EXPOSE 8080# 镜像启动时执行的命令CMD [\"./app\"]# 构建命令#docker build -t goweb . 2. docker-compose.ymldocker-compose.ymlview raw1234567891011121314version: \"3\"services: # nginx nginx: # 服务名称 image: \"nginx\" #镜像 depends_on: - goweb ports: - \"80:80\" # 开放端口 goweb: # 服务名称 image: \"goweb\" #镜像 alpine: image: \"daocloud.io/alpine\" command: [\"ping\",\"127.0.0.1\"] 3. 启动12345docker-compose up -d# Creating network \"009-nginx_default\" with the default driver# Creating 009-nginx_alpine_1 ... done# Creating 009-nginx_goweb_1 ... done# Creating 009-nginx_nginx_1 ... done 4. 测试打开网址： http://www-wh.anycps.com/ 结语 通过之前几节课程，细心的小伙伴可能都发现了。在使用compose之后我们并没有配置网络，但是测试以后发现nginx和goweb是互通的，表明已经存在链接。因为docker-compose会自动创建一个网络，以供内部通信。 实际操作以后发现，步骤还是挺多的，抛开配置文件不说。我们还需要自己去对镜像打包，所以还不够。我们还需要更加自动一点。 4. 深入 docker-compose.yml自动构建docker-compose.ymlview raw1234567891011121314151617181920version: \"3\"services: nginx: # 自动构建 build: context: . # 指定构建目录 image: \"test/nginx:compose\" #指定镜像名称，打包以后镜像就叫这个名称 depends_on: - goweb ports: - \"80:80\" goweb: build: context: \"../004-go\" ports: - 8080 image: \"test/goweb:compose\" alpine: image: \"daocloud.io/alpine\" command: [\"ping\",\"127.0.0.1\"] 服务扩容（Scale）12# 将goweb 扩容到5个服务docker-compose scale goweb=5 注意事项 扩容以后的服务，自动会被docker dns 进行dns负载，所以每次请求的相同服务会得到不同结果。 如果启用了对外端口的服务，不能进行扩容。因为端口占用。 由于nginx为了提升效率，会缓存dns解析结果，所以默认的nginx 代理配置。将无法实现负载。 实现负载的nginx配置 www.confview raw12345678910111213141516171819202122232425262728server { listen 80; location / { root /usr/share/nginx/html; index index.html index.htm; }} # 配置参考 # docker内置dnsserver工作机制: http://dockone.io/article/2316# Using Containers to Learn Nginx Reverse Proxy : https://medium.com/@joatmon08/using-containers-to-learn-nginx-reverse-proxy-6be8ac75a757server{ listen 80; server_name www-wh.anycps.com; location / { # 设置dns 服务，docker dns默认ip 127.0.0.11 resolver 127.0.0.11 valid=5s; # 设置代理 set $upstream_endpoint http://goweb:8080; proxy_pass $upstream_endpoint; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Host $server_name; }}","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"Docker入门教程（八）Docker Network","slug":"docker-008","date":"2019-05-22T06:33:01.000Z","updated":"2020-02-10T11:07:12.016Z","comments":true,"path":"2019/05/22/docker-008/","link":"","permalink":"https://wolferhua.github.io/2019/05/22/docker-008/","excerpt":"","text":"之前我们使用了，IP和link方式对容器进行关联。IP方式不太灵活，但是操作传统比较简单。link 实际上是 network 的简单应用，程序更加灵活了。但是遗憾的是他已经过时了，针对这种情况。docker 推荐我们使用 network，那么接下来我们就一起来学习一下吧。 基础演示0. 网络状态演示启用两个镜像容器1234# alpine1docker run -d -it --rm --name alpine1 daocloud.io/alpine ping 127.0.0.1# alpie2docker run -d -it --rm --name alpine2 daocloud.io/alpine ping 127.0.0.1 进入任意一个容器尝试联通另一个容器123# 进入alpine2 ping alpine1$ docker exec -it alpine2 ping alpine1ping: bad address 'alpine1' 可以发现两个容器之间是互不相通的。当然这个是相对的，其实我们通过容器ip是可以连接的。只是不能通过名称连接而已，之前我们使用link方式让两个容器互相关联起来。接下来我们开始使用network的方式。 1. 创建network123456789101112## 创建网络docker network create --driver bridge alpine-net## 查看网络列表docker network ls# NETWORK ID NAME DRIVER SCOPE# 4058a6d84e03 alpine-net bridge local# 529130bc5057 bridge bridge local# 42c01d942ee6 docker_gwbridge bridge local# 452d8e255625 host host local# rnxd9mcs0v3y ingress overlay swarm 2. 将容器加入网络1234## alpine1docker network connect alpine-net alpine1 ## alpine2docker network connect alpine-net alpine2 3. 进入任意一个容器尝试联通另一个容器123456789# 进入alpine2 ping alpine1docker exec -it alpine2 ping -c 2 alpine1# PING alpine1 (172.19.0.2): 56 data bytes# 64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.147 ms# 64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.167 ms# # --- alpine1 ping statistics ---# 2 packets transmitted, 2 packets received, 0% packet loss# round-trip min/avg/max = 0.147/0.157/0.167 ms 4. 启动容器并加入网络启动容器1docker run -d -it --rm --name alpine3 --network alpine-net daocloud.io/alpine ping 127.0.0.1 查看连接状态123456789# 进入alpine2 ping alpine3docker exec -it alpine2 ping -c 2 alpine3# PING alpine3 (172.19.0.4): 56 data bytes# 64 bytes from 172.19.0.4: seq=0 ttl=64 time=0.222 ms# 64 bytes from 172.19.0.4: seq=1 ttl=64 time=0.184 ms## --- alpine3 ping statistics ---# 2 packets transmitted, 2 packets received, 0% packet loss# round-trip min/avg/max = 0.184/0.203/0.222 ms 实际应用 上一篇我们使用了IP、link的方式来关联镜像，IP方式笨拙，link方式古老。今天我们已经学习了network方式，那么我们就尝试使用network来部署。 1. 创建network1234567docker network create --driver bridge app-net# 查看列表docker network ls# NETWORK ID NAME DRIVER SCOPE# 4058a6d84e03 alpine-net bridge local# 42ce438d3407 app-net bridge local 2. 启动goweb容器1234567891011121314# 清理已经存在的容器docker rm -f goweb# 启动新容器docker run \\--name goweb \\-d \\--network app-net \\-p 8080:8080 \\--restart=always \\goweb:scratch# --network app-net # 指定容器network 2. 启动nginx容器1234567891011121314# 清理已经存在的容器docker rm -f nginx80# 启用新容器# 容器启动基本没有区别，但是取消了 --link 增加 --network 选项docker run \\--name nginx80 \\--network app-net \\-d \\-v ~/workspace/www/goweb.conf:/etc/nginx/conf.d/goweb.conf \\-p 80:80 \\--restart=always \\daocloud.io/nginx 3. 测试访问打开网址：http://www-wh.anycps.com 测试成功，容器关联学习完成。","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"Docker入门教程（七）镜像关联","slug":"docker-007","date":"2019-05-22T05:46:17.000Z","updated":"2020-02-10T11:07:12.016Z","comments":true,"path":"2019/05/22/docker-007/","link":"","permalink":"https://wolferhua.github.io/2019/05/22/docker-007/","excerpt":"","text":"通过之前的内容我们已经成功制作了 nginx 和 go web 的镜像。在实际工作中，我们可能存在多个 go web 分别监听不同的端口，实现了对应的业务。 启动Goweb12345678910# 清理已经存在的容器docker rm -f goweb# 启动新容器docker run \\--name goweb \\-d \\-p 8080:8080 \\--restart=always \\goweb:scratch 1. IP关联 IP关联逻辑最简单，但是由于docker容器每次申请时获取到的IP都不一样。所以我们就不使用容器的IP转而使用宿主机的IP。 查看容器IP 这是只是演示一下，没有具体使用这个IP。 12docker inspect --format='&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;' goweb# 172.17.0.4 查看宿主机IP123456789101112131415161718192021222324252627282930# windowsipconfig# 无线局域网适配器 WLAN:# 连接特定的 DNS 后缀 . . . . . . . :# 本地链接 IPv6 地址. . . . . . . . : fe80::1cb2:ed82:6180:a0ee%9# IPv4 地址 . . . . . . . . . . . . : 192.168.3.159# 子网掩码 . . . . . . . . . . . . : 255.255.255.0# 默认网关. . . . . . . . . . . . . : 192.168.3.1#linux &amp; Mac OS## 传统方式ifconfig## 新模式ip addr#ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000# link/ether 00:0c:29:f2:ec:58 brd ff:ff:ff:ff:ff:ff# inet 192.168.65.128/24 brd 192.168.65.255 scope global dynamic noprefixroute ens33# valid_lft 1030sec preferred_lft 1030sec# inet 192.168.65.95/24 brd 192.168.65.255 scope global secondary noprefixroute ens33# valid_lft forever preferred_lft forever# inet6 fe80::20c:29ff:fef2:ec58/64 scope link dadfailed tentative # valid_lft forever preferred_lft forever### 192.168.65.95 nginx配置文件goweb.confview raw1234567891011121314151617181920server{ listen 80; server_name www-wh.anycps.com; location / { proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; proxy_pass http://up-goweb; chunked_transfer_encoding off; }}upstream up-goweb { ip_hash; # server 127.0.0.1:8080; # 切记这里不能使用 127.0.0.1 # 因为之前我们说过，容器里边是一个独立的环境，127.0.0.1 代表了当前容器。 # 使用我们之前获取到的宿主机IP server 192.168.65.95:8080; } 启动nginx123456789101112# 清理已经存在的容器docker rm -f nginx80# 启用新容器docker run \\--name nginx80 \\-d \\-v ~/workspace/www/goweb.conf:/etc/nginx/conf.d/goweb.conf \\-p 80:80 \\--restart=always \\daocloud.io/nginx 测试访问打开网址：http://www-wh.anycps.com 2. LINK关联 link 关联已经过时，docker官方已经不推荐使用。该功能可能会在未来某个版本被关闭，请谨慎采用。 nginx配置文件goweb.confview raw1234567891011121314151617181920212223server{ listen 80; server_name www-wh.anycps.com; location / { proxy_set_header X-Forwarded-For $remote_addr; proxy_set_header Host $http_host; # link 模式时直接使用 --link 的名称连接即可 proxy_pass http://goweb:8080; chunked_transfer_encoding off; }}# --link 模式不需要这个了。# upstream up-goweb {# ip_hash;# # server 127.0.0.1:8080; # 切记这里不能使用 127.0.0.1# # 因为之前我们说过，容器里边是一个独立的环境，127.0.0.1 代表了当前容器。# # 使用我们之前获取到的宿主机IP# server 192.168.65.95:8080; # } 启动nginx123456789101112131415# 清理已经存在的容器docker rm -f nginx80# 启用新容器# 容器启动基本没有区别，不同的是新增加了 --link 选项# --link &lt;name or id&gt;[:alias]docker run \\--name nginx80 \\--link goweb:goweb \\-d \\-v ~/workspace/www/goweb.conf:/etc/nginx/conf.d/goweb.conf \\-p 80:80 \\--restart=always \\daocloud.io/nginx 测试访问打开网址：http://www-wh.anycps.com","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"Docker入门教程（六）Dockerfile（下）-Go WEB 服务镜像","slug":"docker-006","date":"2019-05-16T12:14:50.000Z","updated":"2020-02-10T11:07:12.016Z","comments":true,"path":"2019/05/16/docker-006/","link":"","permalink":"https://wolferhua.github.io/2019/05/16/docker-006/","excerpt":"","text":"这一节我们需要做一个和项目相关的一个镜像，这个镜像能够运行一个http服务。 0. 创建程序main.goview raw12345678910111213141516171819202122package mainimport ( \"os\" \"log\" \"net/http\")type helloHandler struct{}var host = \"\"func (h *helloHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Content-Type\", \"text/html; charset=UTF-8\" ) w.Header().Set(\"Content-Transfer-Encoding\", \"quoted-printable\") w.Write([]byte(\"Host：\"+host+\"&lt;br&gt; Hello, world! from golang.\")) //输出内容}func main() { host, _ = os.Hostname() //获取当前机器名称 http.Handle(\"/\", &amp;helloHandler{}) log.Println(\"Start web service: http://127.0.0.1:8080\") log.Fatal(http.ListenAndServe(\":8080\", nil)) //指定端口} 1. 使用Golang镜像创建DockerfileDockerfileview raw1234567891011121314151617181920212223242526272829303132# 指定基础镜像, 必须存在于Dockerfile 第一行FROM daocloud.io/golang# 作者信息MAINTAINER wolferhua &lt;wolferhua@qq.com&gt; # 添加文件到镜像ADD . /usr/src/app# 切换目录，相当于cd xxxWORKDIR /usr/src/app# 执行编译gRUN go build -o app main.go # 切换目录WORKDIR /app# 将编译后的移动到 /app 目录RUN mv /usr/src/app/app .# 开放端口，在运行时，并不会正在的开放端口。还是需要-p# 这里只是标明需要使用的端口EXPOSE 8080# 镜像启动时执行的命令CMD [\"./app\"]# 构建命令#docker build -t goweb . 构建12345678910111213141516171819202122232425262728293031323334353637docker build -t goweb .###### output ####### Sending build context to Docker daemon 4.608kB# Step 1/9 : FROM daocloud.io/golang# ---&gt; 1cdc81f11b10# Step 2/9 : MAINTAINER wolferhua &lt;wolferhua@qq.com&gt;# ---&gt; Using cache# ---&gt; a217ea00567b# Step 3/9 : ADD . /usr/src/app# ---&gt; 1d9a89ebab03# Step 4/9 : WORKDIR /usr/src/app# ---&gt; Running in 06a978520d7b# Removing intermediate container 06a978520d7b# ---&gt; 980f422c4a1b# Step 5/9 : RUN go build -o app main.go# ---&gt; Running in c3ef068bda33# Removing intermediate container c3ef068bda33# ---&gt; f51cfc40c95e# Step 6/9 : WORKDIR /app# ---&gt; Running in a36e737525c4# Removing intermediate container a36e737525c4# ---&gt; 1164e24a33ea# Step 7/9 : RUN mv /usr/src/app/app .# ---&gt; Running in 61ddf6b520b2# Removing intermediate container 61ddf6b520b2# ---&gt; 971d70071cfc# Step 8/9 : EXPOSE 8080# ---&gt; Running in dce834bc85e6# Removing intermediate container dce834bc85e6# ---&gt; ad0d8d46670c# Step 9/9 : CMD [\"./app\"]# ---&gt; Running in a4c65296f408# Removing intermediate container a4c65296f408# ---&gt; 968083fe7ffd# Successfully built 968083fe7ffd# Successfully tagged goweb:latest 查看镜像123$ docker images REPOSITORY TAG IMAGE ID CREATED SIZEgoweb latest 968083fe7ffd 4 days ago 741MB # golang 镜像，由于包含了go环境，所以镜像特别大 运行镜像12345678docker run \\--name goweb \\-d \\-p 8080:8080 \\--restart=always \\goweb# output 599eba20d9e98ef282bac9247d2040c0461f62d5ab223e776a88fc0e20ea62ea 测试打开网址：http://127.0.0.1:8080 2. 使用 scratch 上面我们使用了golang的基础镜像，这个镜像包含了程序的基础环境。所以体积较大，接近800M。但是我们知道，go程序是可以直接生成可执行文件的。所以我们需要可以只使用可执行文件来打包镜像，以节省空间占用。 DockerfileDockerfileview raw123456789101112131415# 指定基础镜像, 必须存在于Dockerfile 第一行# 使用基础镜像，这个镜像是一个空的镜像，没有任何内容。且不能执行任何命令FROM scratch# 作者信息MAINTAINER wolferhua &lt;wolferhua@qq.com&gt; # 切换目录，相当于cd xxxWORKDIR /app/# 添加文件到镜像ADD /main /app/ # 执行命令CMD [\"/app/main\"] 构建buildview raw123456789#!/usr/bin/env bash # 执行编译# scratch 镜像完全是空的，什么东西也不包含，所以生成main时候要按照下面的方式生成，使生成的main静态链接所有的库：CGO_ENABLED=0 GOOS=linux go build -v -a -installsuffix cgo -o main .# 执行构建docker build -t goweb:scratch . 查看镜像1234$ docker images REPOSITORY TAG IMAGE ID CREATED SIZEgoweb scratch ff7862ec2d63 About a minute ago 6.5MB # 使用 scratch 只是程序大小，节省空间。goweb latest 968083fe7ffd 4 days ago 741MB # golang 镜像，由于包含了go环境，所以镜像特别大 运行镜像12345678docker run \\--name goweb \\-d \\-p 8080:8080 \\--restart=always \\goweb:scratch# output f350e19ee173c45cefa3a70b…… 测试打开网址：http://127.0.0.1:8080","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"Docker入门教程（五）Dockerfile（中）-常用指令","slug":"docker-005","date":"2019-05-16T08:22:18.000Z","updated":"2020-02-10T11:07:12.016Z","comments":true,"path":"2019/05/16/docker-005/","link":"","permalink":"https://wolferhua.github.io/2019/05/16/docker-005/","excerpt":"","text":"前面我们通过Dockerfile制作了一个简单的nginx镜像，制作过程中我们仅仅使用了三个指令（FROM、MAINTAINER、ADD）。Dockerfile 还有许多其他指令，我们一起来学习一下。 FROM 指定基础镜像，所有镜像都必须有一个基础镜像。所以这个指令必须在整个文档的最前边。 格式1234FROM imageFROM image[:tag]FROM image[@&lt;digest]# 三种写法，其中&lt;tag&gt;和&lt;digest&gt; 是可选项，如果没有选择，那么默认值为latest MAINTAINER 作者 格式12MAINTAINER name MAINTAINER name [&lt;email@mail.com&gt;] ADD | COPY 向镜像中添加文件 格式123456789101112131415# 匹配文件添加ADD hom* /mydir/ ADD hom?.txt /mydir/ COPY hom* /mydir/ COPY hom?.txt /mydir/ # 添加并更改文件所有权ADD --chown=55:mygroup files* /somedir/ADD --chown=bin files* /somedir/ADD --chown=1 files* /somedir/ADD --chown=10:11 files* /somedir/COPY --chown=55:mygroup files* /somedir/COPY --chown=bin files* /somedir/COPY --chown=1 files* /somedir/COPY --chown=10:11 files* /somedir/ ADD 和 COPY 区别大家可能发现了，ADD 和 COPY 貌似实现了相同的功能，但是为啥要出现两个命令呢？是docker官方吃多了么？ – 尼古拉斯·码侠 ADD和COPY的区别： ADD如果添加的是一个压缩包 tar ，添加时会自动解压。 ADD如果添加的是一个网址，那么会自动下载文件并添加。 RUN 执行一条命令 格式12RUN &lt;command&gt; RUN [\"executable\", \"param1\", \"param2\"] EXPOSE 标识开放端口 格式1234EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]# EXPOSE 80# EXPOSE 80/udp# 切记：这里只是标识一下开放的端口，在run的时候并不会真的将端口开放出去。还是需要 -p来指定开放的端口。 WORKDIR 切换工作目录,相当于 : mkdir -p /path/to/workdir &amp;&amp; cd /path/to/workdir 格式1WORKDIR /path/to/workdir USER 指定用户 格式12USER &lt;user&gt;[:&lt;group&gt;] orUSER &lt;UID&gt;[:&lt;GID&gt;] ENV 设置环境变量 格式1234ENV &lt;key&gt; &lt;value&gt;ENV &lt;key&gt;=&lt;value&gt; ...# ENV GOPATH=/path/to/go ENTRYPOINT | CMD 容器启动时执行命令 格式1234ENTRYPOINT [\"executable\", \"param1\", \"param2\"] ENTRYPOINT command param1 param2 CMD [\"executable\", \"param1\", \"param2\"] CMD command param1 param2 ENTRYPOINT 和 CMD 区别 当我们运行容器时如果指定了命令，那么 CMD会被覆盖，但是 ENTRYPOINT 不会。 如果存在ENTRYPOINT ，CMD命令的值将作为ENTRYPOINT的参数。 构建镜像Dockerfileview raw12345FROM ubuntuENTRYPOINT [\"echo\", \"hello\"]CMD [\"world\"]# docker build -t test . 运行镜像1234567# 运行时不指定 commanddocker run --rm testhello world# 运行时指定 command docker run --rm test bashhello bash","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"使用 dd 命令为 linux 创建 swap 交换分区","slug":"dd-add-swap","date":"2019-05-16T03:36:12.000Z","updated":"2020-02-10T11:07:12.016Z","comments":true,"path":"2019/05/16/dd-add-swap/","link":"","permalink":"https://wolferhua.github.io/2019/05/16/dd-add-swap/","excerpt":"","text":"操作过程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 1. 创建交换分区文件# 将/dev/zero内容写入/data/swapfile，读写块大小1024bytes ，块个数8192。 # /dev/zero是个未使用的文件模版，可以用它来创建“干净”的文件。后两个参数可以控制文件大小。 mkdir -p /datadd if=/dev/zero of=/data/swapfile bs=1M count=8192# output：# 8192+0 records in# 8192+0 records out# 8589934592 bytes (8.6 GB, 8.0 GiB) copied, 33.3621 s, 257 MB/s# 2. 把这个文件变成swap文件mkswap /data/swapfile # output：# Setting up swapspace version 1, size = 8 GiB (8589930496 bytes)# no label, UUID=42f6d7ee-b744-42dd-bc9e-f8cd4393af3a# 3. 激活使用这个swap文件 swapon /data/swapfile # output：# swapon: /data/swapfile: insecure permissions 0644, 0600 suggested.# 4. 查看状态swapon -s# output：# Filename Type Size Used Priority# /data/swapfile file 8388604 0 -1# 5. 设置自动挂载交换分区# 将 /data/swapfile swap swap defaults 0 0 写入文件 /etc/fstabecho \"/data/swapfile swap swap defaults 0 0\" &gt;&gt; /etc/fstab# 6. 启用系统交换分区配置# swappiness的值的大小对如何使用swap分区是有着很大的联系的。swappiness=0的时候表示最大限度使用物理内存，然后才是 swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。linux的基本默认设置为60。也就是说，你的内存在使用到100-60=40%的时候，就开始出现有交换分区的使用。大家知道，内存的速度会比磁盘快很多，这样子会加大系统io，同时造的成大量页的换进换出，严重影响系统的性能，所以我们在操作系统层面，要尽可能使用内存，对该参数进行调整。## 6.1 查看当前配置cat /proc/sys/vm/swappiness## 6.2 临时调整sysctl vm.swappiness=60## 6.3 永久调整### 6.31 编辑配置文件vim /etc/sysctl.conf### 6.32 追加或修改vm.swappiness=60### 6.33 启用配置sysctl -p # read values from file 拓展删除交换分区1. 停止交换分区1swapoff /data/swapfile 2. 删除/etc/fstab中的自动挂载12vim /etc/fstab# /data/swapfile swap swap defaults 0 0 3. 删除分区文件1rm /data/swapfile","categories":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"}]},{"title":"[LeetCode]有效的数独","slug":"leetcode-isValidSudoku","date":"2019-05-13T09:19:24.000Z","updated":"2020-02-10T11:07:12.015Z","comments":true,"path":"2019/05/13/leetcode-isvalidsudoku/","link":"","permalink":"https://wolferhua.github.io/2019/05/13/leetcode-isvalidsudoku/","excerpt":"","text":"需求判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2: 123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。 实现GO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465func isValidSudoku(board [][]byte) bool &#123; xl := 9 checkSudokuByPoint := func(points [][]int, board [][]byte) bool &#123; sudokuMap := map[byte]struct&#123;&#125;&#123;&#125; for _, item := range points &#123; su := board[item[0]][item[1]] if su == 46 &#123; //'.' continue &#125; if _, ok := sudokuMap[su]; ok &#123; return false //重复退出 &#125; sudokuMap[su] = struct&#123;&#125;&#123;&#125; &#125; return true &#125; getPoints := func(s int, isX bool) [][]int &#123; points := [][]int&#123;&#125; for i := 0; i &lt; 9; i++ &#123; if isX &#123; points = append(points, []int&#123;s, i&#125;) &#125; else &#123; points = append(points, []int&#123;i, s&#125;) &#125; &#125; //fmt.Println(points) return points &#125; //检查行和列 for i := 0; i &lt; xl; i++ &#123; s := checkSudokuByPoint(getPoints(i, true), board) if !s &#123; return s &#125; s = checkSudokuByPoint(getPoints(i, false), board) if !s &#123; return s &#125; &#125; //获取所有坐标点 getPointByXY := func(x, y int) [][]int &#123; points := [][]int&#123;&#125; for i := x; i &lt; x+3; i++ &#123; for j := y; j &lt; y+3; j++ &#123; points = append(points, []int&#123;i, j&#125;) &#125; &#125; return points &#125; for i := 0; i &lt; xl; i += 3 &#123; for j := 0; j &lt; xl; j += 3 &#123; //fmt.Println([]int&#123;i, j&#125;) s := checkSudokuByPoint(getPointByXY(i, j), board) if !s &#123; return s &#125; &#125; &#125; return true&#125; 大神 使用bitmap实现 1234567891011121314151617181920212223242526272829303132333435363738394041func isValidSudoku(board [][]byte) bool &#123; //获取到 行 ，列 ，区块 的bitmap //fmt.Printf(\"%b\\n\",math.MaxInt16) 00000000000 - 11111111111 row, col, block := make([]int16, 9), make([]int16, 9), make([]int16, 9) var cur int16 for i := 0; i &lt; 9; i++ &#123; for j := 0; j &lt; 9; j++ &#123; // 遇到 . 跳过 if board[i][j] == '.' &#123; continue &#125; // cur表示将1左移“board[i][j]的数字（下面称为当前数字）”个位 // 如 2 的结果是 1&lt;&lt;(50-48) = '100' cur = 1 &lt;&lt; (board[i][j] - '0') // 计算出 当前数字 所在3x3块的索引 bi := i/3 + j/3*3 // 如果 当前数字 已经在row, col, block其中一个bitmap，则返回false // 如 row[i] = 3 1000 // 如 cur = 2 100 //row[i] &amp; cur == 0 // 如 row[i] = 3,2 1100 // 如 cur = 2 100 //row[i] &amp; cur == 100 (!= 0) if (row[i]&amp;cur)|(col[j]&amp;cur)|(block[bi]&amp;cur) != 0 &#123; return false &#125; // 将 当前数字 分别添加到 row, col, block bitmap // 如 row[i] = 3 // 如 cur = 2 //row[i] |= cur == '1100' row[i] |= cur col[j] |= cur block[bi] |= cur &#125; &#125; return true&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"[LeetCode]移动零","slug":"leetcode-moveZeroes","date":"2019-05-13T07:49:57.000Z","updated":"2020-02-10T11:07:12.015Z","comments":true,"path":"2019/05/13/leetcode-movezeroes/","link":"","permalink":"https://wolferhua.github.io/2019/05/13/leetcode-movezeroes/","excerpt":"","text":"需求给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 实现GO123456789101112131415161718192021222324252627282930func moveZeroes(nums []int) &#123; l := len(nums) if l &lt; 2 &#123; return &#125; for i := 0; i &lt; l; i++ &#123; ni := nums[i]; //为 0 则需要交换 if ni == 0 &#123; mv := false for j := i + 1; j &lt; l; j++ &#123; nj := nums[j] //不为零时则交换位置 if nj != 0 &#123; nums[i], nums[j] = nums[j], nums[i] mv = true break &#125; &#125; if !mv &#123; //不存在交换的数据，表示剩下的数据都是 0，退出交换 break &#125; &#125; &#125; &#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"[LeetCode]加一","slug":"leetcode-plusOne","date":"2019-05-09T13:04:09.000Z","updated":"2020-02-10T11:07:12.015Z","comments":true,"path":"2019/05/09/leetcode-plusone/","link":"","permalink":"https://wolferhua.github.io/2019/05/09/leetcode-plusone/","excerpt":"","text":"需求给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 实现GO123456789101112131415161718192021func plusOne(digits []int) []int &#123; l := len(digits) p := 1 for i := l - 1; i &gt;= 0; i-- &#123; n := digits[i] + p if n &lt; 10 &#123; digits[i] = n p = 0 break &#125; else &#123; p = n / 10 n = n % 10 digits[i] = n &#125; &#125; if p &gt; 0 &#123; digits = append([]int&#123;p&#125;, digits...) &#125; return digits&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"[LeetCode]存在重复","slug":"leetcode-containsDuplicate","date":"2019-05-09T12:18:34.000Z","updated":"2020-02-10T11:07:12.014Z","comments":true,"path":"2019/05/09/leetcode-containsduplicate/","link":"","permalink":"https://wolferhua.github.io/2019/05/09/leetcode-containsduplicate/","excerpt":"","text":"需求给定一个整数数组，判断是否存在重复元素。 如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。 示例 1: 12输入: [1,2,3,1]输出: true 示例 2: 12输入: [1,2,3,4]输出: false 示例 3: 12输入: [1,1,1,3,3,4,3,2,4,2]输出: true 实现GO1234567891011func containsDuplicate(nums []int) bool &#123; numsMap := map[int]bool&#123;&#125; for _, v := range nums &#123; if _, ok := numsMap[v]; ok &#123; return true &#125; numsMap[v] = true; &#125; return false&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"[LeetCode]旋转数组","slug":"leetcode-rotate","date":"2019-05-09T12:15:41.000Z","updated":"2020-02-10T11:07:12.015Z","comments":true,"path":"2019/05/09/leetcode-rotate/","link":"","permalink":"https://wolferhua.github.io/2019/05/09/leetcode-rotate/","excerpt":"","text":"需求给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例 1: 123456输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例 2: 12345输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明: 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 要求使用空间复杂度为 O(1) 的原地算法。 实现GO12345678910111213141516171819202122232425262728func rotate(nums []int, k int) &#123; l := len(nums) if l &lt; 2 &#123; return &#125; if k == l &#123; return &#125; if k &gt; l &#123; k = k % l &#125; // 获取 最后 k 个元素 knums := nums[l-k:] lnums := make([]int, l-k) copy(lnums,nums[:l-k]) for i := 0; i &lt; l; i++ &#123; if i &lt; k &#123; nums[i] = knums[i] &#125; else &#123; nums[i] = lnums[i-k] &#125; &#125;&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"[LeetCode]只出现一次的数字","slug":"leetcode-singleNumber","date":"2019-05-09T12:15:29.000Z","updated":"2020-02-10T11:07:12.015Z","comments":true,"path":"2019/05/09/leetcode-singlenumber/","link":"","permalink":"https://wolferhua.github.io/2019/05/09/leetcode-singlenumber/","excerpt":"","text":"需求给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 123输入: [2,2,1]输出: 1示例 2: 12输入: [4,1,2,1,2]输出: 4 实现GO1234567891011121314151617181920212223242526func singleNumber(nums []int) int &#123; l := len(nums) now := 0 rep := 0 du := false for i := 0; i &lt; l; i++ &#123; now = nums[i] //当前元素 du = false for j := i + 1; j &lt; l; j++ &#123; rep = nums[j] if now == rep &#123; du = true //重复 nums[i+1], nums[j] = nums[j], nums[i+1] break &#125; &#125; if du &#123; i++ //前进一位 &#125; else &#123; return now &#125; &#125; return 0&#125; 大神1234567func singleNumber(nums []int) int &#123; res := 0 for _, v := range nums &#123; res ^= v &#125; return res&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"Docker入门教程（四）Dockerfile（上）-自定义镜像","slug":"docker-004","date":"2019-05-09T06:58:38.000Z","updated":"2019-05-16T06:58:38.000Z","comments":true,"path":"2019/05/09/docker-004/","link":"","permalink":"https://wolferhua.github.io/2019/05/09/docker-004/","excerpt":"","text":"之前我们使用的都是官方提供的一些镜像，这些镜像有一个共同点：大众可用。任何人都可以开箱使用它，但是实际工作中。我们总有这样那样的一些需求，这些官方提供的镜像就满足不了我们，我们就需要对镜像做一些个性化的操作。 为了方便学习，我们提一个虚拟的需求：对nginx进行自定义，打开首页显示&#39;Hello Word&#39;。 Commit 模式启动镜像 docker run 123456789docker run \\--name nginx80 \\-d \\-p 80:80 \\--restart=always \\daocloud.io/nginx# 启动以后获取到一个容器编号。# 0417f4faebb46ee6dbbcfe3b8fee634f56b16d52a277b0ab300d56e2bc013116 在之前的课程中我们了解到，docker 使用镜像和容器 可以分别使用 ID 和名称两种方式，上边我们对nginx 镜像启动的容器命名为 nginx80 ,之后我们就使用容器名来操作。 测试启动状态打开网址：http://127.0.0.1 修改文件内容 docker exec 1234567891011# 进入docker 容器$ docker exec -it nginx80 bash # 容器内操作# 进入nginx 目录root@0417f4faebb4:/# cd /usr/share/nginx/html/# 更改文件内容root@0417f4faebb4:/usr/share/nginx/html# echo \"Hello Word\" &gt; index.html# 退出容器root@0417f4faebb4:/usr/share/nginx/html# exitexit 测试修改情况打开网址：http://127.0.0.1 将容器生成一个镜像 docker commit 1234docker commit -a \"wolferhua &lt;wolferhua@qq.com&gt;\" nginx80 wolferhua/nginx80# 获取到镜像ID# sha256:3292610adc359af0330d4c2a2bf97c56c62f9b052d98d7d22ded8fe7ca4922b2 检查生成状态12345$ docker images## 镜像列表REPOSITORY TAG IMAGE ID CREATED SIZEwolferhua/nginx80 latest 3292610adc35 57 seconds ago 109MB # 新生成的容器daocloud.io/nginx latest 27a188018e18 4 weeks ago 109MB # 源容器 运行新镜像删除旧容器 由于端口 和 容器名称 可能存在占用情况，我们需要将之前的容器删除。 1docker rm -f nginx80 运行容器123456789101112docker run \\--name nginx80 \\-d \\-p 80:80 \\--restart=always \\wolferhua/nginx80 # 最后的镜像名称使用新的镜像名称 ： wolferhua/nginx80 # 启动以后获取到一个容器编号。# cdaea8916c4431373120f06bc85e888076e17f38fea60df740b16866aaee0f13 测试运行情况打开网址：http://127.0.0.1 结语通过之前的操作，我们实现了容器的自定义。可以在重新运行一下源镜像和新镜像进行对比。可以发现镜默认页面存在差异。但是之前的操作，过于繁琐。而且可制定化比较小，而且之前的课程中我峨嵋你测试过，在镜像中默认是不能使用vi等命令的，需要安装,徒增镜像空间占用。 Dockerfile 模式Dockerfile 是一组命令的组合，Docker 通过这些命令生成镜像。Dockerfile 理论上支持所有的 shell 命令。 基础资源创建目录12mkdir -p nginx80cd nginx80 创建 index.htmlindex.htmlview raw1&lt;h1&gt;Hello World!&lt;/h1&gt; Dockerfile创建 Dockerfile123# 在nginx80 目录下创建文件vim Dockerfile 写入以下内容： Dockerfileview raw1234567891011# 指定基础镜像, 必须存在于Dockerfile 第一行FROM daocloud.io/nginx# 作者信息MAINTAINER wolferhua &lt;wolferhua@qq.com&gt;# 添加文件到镜像# 将 index.html 添加到 /usr/share/nginx/htmlADD ./index.html /usr/share/nginx/html BUID 构建docker build 123456789101112docker build -t nginx80 .# Sending build context to Docker daemon 3.072kB# Step 1/3 : FROM daocloud.io/nginx# ---&gt; 27a188018e18# Step 2/3 : MAINTAINER wolferhua &lt;wolferhua@qq.com&gt;# ---&gt; Running in e41238d1a82b# Removing intermediate container e41238d1a82b# ---&gt; 75444be66b52# Step 3/3 : ADD ./index.html /usr/share/nginx/html# ---&gt; 650d7a2528ba# Successfully built 650d7a2528ba# Successfully tagged nginx80:latest 命令最后有一个 . 字符，表示当前目录的Dockerfile。 检查构建情况12345docker images# REPOSITORY TAG IMAGE ID CREATED SIZE# nginx80 latest 650d7a2528ba 2 minutes ago 109MB # dockerfile 构建# wolferhua/nginx80 latest 3292610adc35 5 hours ago 109MB # commit 方式创建# daocloud.io/nginx latest 27a188018e18 4 weeks ago 109MB # 源镜像 运行容器1234567891011121314docker rm -f nginx80docker run \\--name nginx80 \\-d \\-p 80:80 \\--restart=always \\nginx80 # 最后的镜像名称使用新的镜像名称 ： nginx80 # 启动以后获取到一个容器编号。# 302df2f5446ac799a865896debc35790908cb5ebbccde8925dbe402596e04152 测试运行情况打开网址：http://127.0.0.1","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"Docker入门教程（三）Docker常用命令解析","slug":"docker-003","date":"2019-05-09T01:50:03.000Z","updated":"2019-05-16T06:58:38.000Z","comments":true,"path":"2019/05/09/docker-003/","link":"","permalink":"https://wolferhua.github.io/2019/05/09/docker-003/","excerpt":"","text":"RUN docker run ：创建一个新的容器并运行 格式1docker run [OPTIONS] IMAGE [COMMAND] [ARG...] 参数 -a stdin : 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项； -d : 后台运行容器，并返回容器ID； -i : 以交互模式运行容器，通常与 -t 同时使用； -p : 端口映射，格式为：主机(宿主)端口:容器端口 -t : 为容器重新分配一个伪输入终端，通常与 -i 同时使用； --name=&quot;nginx&quot; : 为容器指定一个名称； --dns 8.8.8.8 : 指定容器使用的DNS服务器，默认和宿主一致； --dns-search example.com : 指定容器DNS搜索域名，默认和宿主一致； -h &quot;nginx&quot; : 指定容器的hostname； -e envname=&quot;value&quot; : 设置环境变量； --env-file=[] : 从指定文件读入环境变量； --cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot; : 绑定容器到指定CPU运行； -m :设置容器使用内存最大值； --net=&quot;bridge&quot; : 指定容器的网络连接类型，支持 bridge/host/none/container : 四种类型； --link=[] : 添加链接到另一个容器；--link &lt;name or id&gt;[:alias] --expose=[] : 开放一个端口或一组端口； -v local/dir:docker/dir ：挂载目录 START/STOP/RESTARTdocker start : 启动一个或多个已经被停止的容器 docker stop : 停止一个或多个运行中的容器 docker restart : 重启容器 格式123docker start [OPTIONS] CONTAINER [CONTAINER...]docker stop [OPTIONS] CONTAINER [CONTAINER...]docker restart [OPTIONS] CONTAINER [CONTAINER...] KILLdocker kill :强行停止一个运行中的容器。 格式1docker kill [OPTIONS] CONTAINER [CONTAINER...] rmdocker rm ：删除一个或多少容器 格式1docker rm [OPTIONS] CONTAINER [CONTAINER...] 参数 -f, --force 强行删除，正在运行的容器发送 SIGKILL 停止信号后删除 -l, --link 移除容器间的网络链接 -v, --volumes 删除与容器关联的数据卷 EXECdocker exec ：在运行的容器中执行命令 格式1docker exec [OPTIONS] CONTAINER COMMAND [ARG...] 参数 -d, --detach : 后台运行命令 -e, --env list : 环境变量 -i, --interactive : 输入 -t, --tty : 模拟终端 -u, --user string ： 指定用户登录 (format: &lt;name|uid&gt;[:&lt;group|gid&gt;]) -w, --workdir string ： 指定登陆后默认目录 PSdocker ps : 列出容器 格式1docker ps [OPTIONS] 参数 -a, --all ： 显示所有 (默认只显示正在运行的) -n, --last int ： 现在最近创建的n个 -l, --latest ： 显示最近创建的 -q, --quiet ： 只显示容器编号 -s, --size ： 显示文件总大小 IMAGESdocker images : 列出本地的镜像列表 格式1docker images [OPTIONS] [REPOSITORY[:TAG]] 参数 -a, --all ： 显示所有 -q, --quiet ： 显示镜像ID STATSdocker stats : 限制运行容器的资源占用信息，CPU、内存、网络 格式1docker stats [OPTIONS] [CONTAINER...] 参数 -a, --all ： 显示所有 COMMITdocker commit : 通过容器创建一个新的镜像 格式1docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]] 参数: -a, --author string 作者 (e.g., “John Hannibal Smith &#104;&#x61;&#110;&#110;&#105;&#x62;&#97;&#x6c;&#64;&#x61;&#x2d;&#116;&#101;&#97;&#x6d;&#x2e;&#x63;&#111;&#x6d;“) -m, --message string 提交信息，类似git commit -m &quot;message&quot; BUILDdocker build : 使用Dockerfile构建镜像 格式1docker build [OPTIONS] PATH | URL | - 参数 --rm 编译成功以后删除缓存数据，编译过程中会生成一些中间镜像。 -t, --tag list 镜像标签，格式: ‘name:tag’ HELPdocker help : 查看命令帮助信息 格式1docker help [command]","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"Docker入门教程（二）Docker 运行 Nginx","slug":"docker-002","date":"2019-05-08T08:02:50.000Z","updated":"2020-02-10T11:07:12.014Z","comments":true,"path":"2019/05/08/docker-002/","link":"","permalink":"https://wolferhua.github.io/2019/05/08/docker-002/","excerpt":"","text":"启动 Nginx之前我们以及对Docker有一个初步的认识，并且运行了docker。接下来我们需要用docker来实现nginx服务。废话不多说，先上代码： 123456789101112# 在控制台中输入以下代码# 启动nginx docker run \\--name nginx80 \\-d \\-v ~/workspace/www:/usr/share/nginx/html \\-p 80:80 \\--restart=always \\daocloud.io/nginx# 删除正在运行的容器# docker rm -f nginx80 测试在浏览器中输入： http://127.0.0.1 代码解析12345678910111213141516171819202122232425262728# docker run 指令docker run \\ #--name 指定容器名称 --name nginx80 \\ # -d 容器进入后台运行 -d \\ # 挂载宿主机数据目录到容器里边 # -v 宿主机目录:挂载到容器以后的目录（无论目录再容器中是否存在，均可挂载）-v ~/workspace/www:/usr/share/nginx/html \\ # 指定对外访问端口# -p 宿主机端口:容器内端口# 要求宿主机端口未被占用-p 80:80 \\ # 异常停止以后重启# always 表示任何情况下都会自动重启。切记是异常情况，正常关闭和停止并不会自动重启--restart=always \\ # 镜像名称daocloud.io/nginx daocloud.io/nginx 由于docker官方的镜像下载速度过慢，所以我们需要使用国内的仓库。使用格式 国内仓库地址/实际镜像名称。由于docker官方的镜像非常多，所以国内的仓库并未完全同步官方仓库，部分镜像可能在国内仓库上找不到。 修改 nginx 配置在实际应用中，可能需要修改nginx 的配置，以达到业务的需求。其实修改的原理也特别简单，就是将本地的配置文件挂载到 nginx 中。 配置域名 http://www-wh.anycps.com/创建配置文件123456789# d.confserver&#123; listen 80; server_name www-wh.anycps.com; location / &#123; root /www; index index.html index.htm; &#125;&#125; 挂载配置文件12345678docker run \\--name nginx80 \\-d \\-v ~/workspace/www:/www \\-v ~/workspace/www/d.conf:/etc/nginx/conf.d/d.conf \\-p 80:80 \\--restart=always \\daocloud.io/nginx 测试在浏览器中输入： http://www-wh.anycps.com 进入容器操作容器运行以后，处于一个独立封闭的状态，外部是不能直接操作。所以我们需要进入容器进行操作。 12# docker exec 配置参数 容器名称 执行命令docker exec -it nginx80 bash 参数 -it-it的作用是模拟一个可以输入的 terminal ,如果不设置这个参数我们就只能干看着。","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://wolferhua.github.io/tags/nginx/"}]},{"title":"Docker入门教程（一）初识 Docker","slug":"docker-001","date":"2019-05-07T14:50:19.000Z","updated":"2020-02-10T11:07:12.014Z","comments":true,"path":"2019/05/07/docker-001/","link":"","permalink":"https://wolferhua.github.io/2019/05/07/docker-001/","excerpt":"","text":"〇、大纲##（一）初始Docker ##（二）使用Docker（nginx） ##（三）使用Docker-常用命令 ##（四）自定义镜像-Dockerfile ##（五）镜像关联-镜像通信 ##（六）docker-compose ##（七）docker-swarem ##（八）docker-swarem 部署集群 一、什么是Docker？ Docker 是一个基于 Go语言 的开源容器引擎。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。并且容器的使用开销极低，启动速度也非常快。 二、 Docker 特点 统一开发环境，方便部署。 灵 活：即使是最复杂的应用也可以容器化。 轻量级：容器利用并共享主机内核。 可互换：您可以即时部署更新和升级。 便携式：您可以在本地构建，部署到云，并在任何地方运行。 可扩展：您可以增加并自动分发容器副本。 可堆叠：您可以垂直和即时堆叠服务。 三、基础概念镜像 操作系统安装盘 Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 容器 安装好的系统 镜像生成的容器实例 ，称为容器 。也就是说，一旦容器生成，就会同时存在两个数据： 镜像 和 容器。而且关闭容器并不会删除容器，只是容器停止运行而已。 仓库 操作系统存储位置 仓库是镜像的集合 - 类似于GitHub存储库。 推荐公开仓库 官方仓库 七牛仓库 DaoCloud 四、 Docker 安装Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。 Docker CE 的安装参考官方文档： Ubuntu CentOS Mac Windows 验证安装1234567891011$ docker versionClient: Version: 18.09.5-ce API version: 1.39 Go version: go1.12.3 Git commit: e8ff056dbc Built: Fri Apr 12 08:22:13 2019 OS/Arch: linux/amd64 Experimental: false 启动命令service 命令的用法1sudo service docker start systemctl 命令的用法1sudo systemctl start docker 注意事项Linux 安装完成以后，非root用户不能直接使用。可能会提示 1Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.39/containers/json: dial unix /var/run/docker.sock: connect: permission denied 解决方案： 确认docker 是否启动: sudo service docker status 或者 sudo systemctl status docker 将当前用户加入到docker用户组：sudo usermod -a -G docker $USER 五、使用Docker Hello world下面我们通过一个简单的镜像hello world，来体验一把docker的使用。使用之前我们来回忆一下平常使用的系统，我们从安装到使用需要做些什么？ 流程如下： 定位喜欢的系统: windows、ubuntu、deepin 、manjaro …… 下载系统。 安装系统。 运行。 玩够了，关机。 那么拆解成docker操作如下。 1. 找到并下载刚刚我们已经说明了我们需要的系统镜像是hello-world,所以无需再去找了，直接下载即可。如需要去找镜像，可以去上面推荐的仓库中寻找，也可以： 12345678$ docker search hello-worldNAME DESCRIPTION STARS OFFICIAL AUTOMATEDhello-world Hello World! (an example of minimal Dockeriz… 909 [OK] kitematic/hello-world-nginx A light-weight nginx container that demonstr… 124 tutum/hello-world Image to test docker deployments. Has Apache… 60 [OK]dockercloud/hello-world Hello World! 15 [OK]crccheck/hello-world Hello World web server in under 2.5 MB 6 [OK]... 需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，可能需要重试几次。 下载镜像 1docker pull hello-world 查看本地镜像列表 1234$ docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest fce289e99eb9 4 months ago 1.84kB 名词解析 REPOSITORY 镜像名称 TAG 镜像标签，可以理解为版本号。 IMAGE ID 镜像id，完整的镜像id很长，在使用时有诸多不便。所以docker协定，使用 ID,如果不重复，六位以上字符即可代表。 2. 安装并运行docker run命令会从镜像，生成一个正在运行的容器实例。相当于是安装并运行。 需要注意的是，docker run会根据名称查找本地的镜像资源，如果存在直接运行，如果不存在则会自动下载并运行。所以之前的下载操docker pull作并不是必须的。 1234567891011121314151617181920212223$ docker run hello-worldHello from Docker!This message shows that your installation appears to be working correctly.To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bashShare images, automate workflows, and more with a free Docker ID: https://hub.docker.com/For more examples and ideas, visit: https://docs.docker.com/get-started/ hello-world 镜像再运行后会输出以上内容，输出以后容器自动停止，停止的容器并不会被删除。我们可以查看一下运行完以后的容器。 查看容器列表 12345$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES091ad60376eb hello-world \"/hello\" 6 minutes ago Exited (0) 6 minutes ago vigilant_kare1ad7da64cfc5 alpine \"ash\" About an hour ago Exited (0) About an hour ago awesome_allen docker ps 只能查看正在运行的容器，查看停止的容器需要添加参数 -a 名词解析 CONTAINER ID ,容器编号，ID规则与前面的 IMAGE ID 规则一样。 IMAGE 镜像。 COMMAND 启动时执行的命令。 CREATED 创建时间。 STATUS 机器状态。 PORTS 使用端口。 NAMES 容器名称，用于标识容器，不可重复。可以再启动时指定。 3. 删除容器停止的容器，理论上是没有任何用处的。所以我们需要将他删除掉 123456# docker rm &#123;容器名称|容器ID&#125; $ docker rm 091ad60376eb091ad60376eb","categories":[{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/categories/docker/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"docker","slug":"docker","permalink":"https://wolferhua.github.io/tags/docker/"}]},{"title":"[LeetCode]买卖股票的最佳时机","slug":"maxProfit","date":"2019-05-05T07:24:44.000Z","updated":"2020-02-10T11:07:12.013Z","comments":true,"path":"2019/05/05/maxprofit/","link":"","permalink":"https://wolferhua.github.io/2019/05/05/maxprofit/","excerpt":"","text":"需求给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 1234输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 12345输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 123输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 实现GO1234567891011121314151617181920212223242526272829303132func maxProfit(prices []int) int &#123; if prices == nil || len(prices) == 0 &#123; return 0 &#125; p := 0 l := len(prices) lp := -1 ipp := 0 for i := 0; i &lt; l; i++ &#123; ipp = 0 if i+1 &lt; l &#123; ipp = prices[i+1] &#125; if lp == -1 &#123; if prices[i] &lt; ipp &#123; //有购买价值 lp = prices[i] &#125; &#125; else &#123; //查找卖出点 if prices[i] &gt; ipp &#123; //卖出 p += prices[i] - lp lp = -1 &#125; &#125; &#125; return p&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"[LeetCode]从排序数组中删除重复项","slug":"leetcode-removeDuplicates","date":"2019-04-29T11:36:46.000Z","updated":"2020-02-10T11:07:12.013Z","comments":true,"path":"2019/04/29/leetcode-removeduplicates/","link":"","permalink":"https://wolferhua.github.io/2019/04/29/leetcode-removeduplicates/","excerpt":"","text":"需求给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 123给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 123给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: 12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 实现Go123456789101112131415161718192021222324func removeDuplicates(nums []int) int &#123; ret := 1 //默认只有一个长度 l := len(nums) //只有一个就不需要操作了 if l &lt; 2 &#123; return l; &#125; else if l == 2 &#123; //当有两个元素时直接对比。 if nums[0] != nums[ret] &#123; return l &#125; return ret; &#125; //多个元素才有处理价值。 for i := 0; i &lt; l; i++ &#123; if nums[i] != nums[ret-1] &#123; nums[i], nums[ret] = nums[ret], nums[i] ret++ &#125; &#125; return ret&#125;","categories":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/categories/leetcode/"},{"name":"array","slug":"leetcode/array","permalink":"https://wolferhua.github.io/categories/leetcode/array/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://wolferhua.github.io/tags/leetcode/"},{"name":"array","slug":"array","permalink":"https://wolferhua.github.io/tags/array/"},{"name":"golang","slug":"golang","permalink":"https://wolferhua.github.io/tags/golang/"}]},{"title":"Linux 安装 java","slug":"install-java-on-linux","date":"2019-04-24T08:53:16.000Z","updated":"2020-02-10T11:07:12.013Z","comments":true,"path":"2019/04/24/install-java-on-linux/","link":"","permalink":"https://wolferhua.github.io/2019/04/24/install-java-on-linux/","excerpt":"","text":"1 . 下载java安装包百度云： https://pan.baidu.com/s/1BYhhyMAqr8ORM946bYWqIw 2 . 上传到服务器1scp jdk-8u211-linux-x64.tar.gz ssh_host:. 解压文件1sudo tar -zxvf jdk-8u211-linux-x64.tar.gz -C /usr/local/lib/ 设置环境变量 每一个账号的home目录里边都有一个 .bashrc 。所以那个用户使用，就在那个账号里边加。如果需要全局安装 vim /etc/profile 即可。 1234567vim ~/.bashrc # 在文件最底部追加以下内容export JAVA_HOME=\"/usr/local/lib/jdk1.8.0_211\"export JRE_HOME=\"$&#123;JAVA_HOME&#125;/jre\"export CLASSPATH=\".:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib\"export PATH=\"$&#123;JAVA_HOME&#125;/bin:$&#123;PATH&#125;\" 设置全局命令12ln -s /usr/local/lib/jdk1.8.0_211/bin/java /usr/bin/javaln -s /usr/local/lib/jdk1.8.0_211/bin/java /usr/share/java 退出重新登录12# 验证安装java -version","categories":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wolferhua.github.io/tags/linux/"},{"name":"java","slug":"java","permalink":"https://wolferhua.github.io/tags/java/"}]},{"title":"对系统架构的理解","slug":"interview-questions","date":"2015-05-07T06:35:59.000Z","updated":"2020-02-10T11:07:12.012Z","comments":true,"path":"2015/05/07/interview-questions/","link":"","permalink":"https://wolferhua.github.io/2015/05/07/interview-questions/","excerpt":"","text":"1.是否了解系统架构 程序架构 程序架构从程序设计出发，应用何种语言、采用哪种设计模式、那些算法。都在考虑范围内 服务架构 服务架构针对部署环节，由于单点抗压能力弱。必定需要集群，这时就需要考虑一下几点： 数据库是否读写分离？ 是否加入缓存，队列？ 前后端分离，动静分离？ 服务器负载均衡配置 2.对于系统安全架构的理解系统安全也从两个角度出发，但是有一个核心：不相信任何外来数据，所有数据必定验证。 程序安全 这种击穿防护，缓存、数据库。 数据库注入。 适时更新系统，如PHP版本 csrf 数据加密等等操作 服务安全 防火墙，指定某些端口开放 维护线上重要服务密码 系统权限管理 Ddos 攻击防护 - 这块没有做过，都是用云服务提供的防护。","categories":[{"name":"面试","slug":"面试","permalink":"https://wolferhua.github.io/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://wolferhua.github.io/tags/面试/"}]}]}